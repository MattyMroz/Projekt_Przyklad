https://www.w3schools.com/python/default.asp

# Python w Konsoli

1. **Uruchamianie Pythona: <br>**
   Aby uruchomić interpreter Pythona, wpisz `python` lub `python3` w wierszu poleceń i naciśnij Enter. Pojawi się interaktywna konsola Pythona, gdzie możesz wpisywać i wykonywać polecenia Pythona.

   Przykład:

   ```python
   $ python
   Python 3.9.6 (default, Jun 29 2021, 10:55:58)
   [GCC 8.4.0] on linux
   Type "help", "copyright", "credits" or "license" for more information.
   >>>
   ```

2. **Wykonywanie poleceń: <br>**
   W konsoli Pythona możesz wpisywać polecenia Pythona linia po linii i naciskać Enter, aby je wykonać. Na przykład:

   ```python
   >>> print("Hello, world!")
   Hello, world!
   ```

3. **Wyjście z konsoli Pythona: <br>**
   Aby wyjść z konsoli Pythona, możesz wpisać `exit()` lub `quit()` lub nacisnąć kombinację klawiszy `Ctrl+D` (na systemach Unix) lub `Ctrl+Z` (na systemach Windows) i Enter.

   Przykład:

   ```python
   >>> exit()
   $

   lub

   >>> quit()
   $
   ```

4. **Wykonywanie skryptów Pythona: <br>**
   Możesz również uruchamiać skrypty Pythona bezpośrednio z konsoli. Aby to zrobić, wpisz `python nazwa_pliku.py` w wierszu poleceń, gdzie `nazwa_pliku.py` to nazwa twojego pliku ze skryptem Pythona.

   Przykład:

   ```python
   $ python my_script.py
   ```

# Komentowanie

1. **Komentarze jednolinijkowe: <br>**
   Możesz komentować pojedynczą linię kodu, umieszczając znak hash `(#)` przed linią kodu.

   Przykład:

   ```python
   # To jest komentarz jednolinijkowy
   x = 5  # Przykładowa linia kodu
   ```

2. **Komentarze wielolinijkowe (docstring): <br>**
   Komentarze wielolinijkowe są używane do pisania dokumentacji funkcji, modułów lub klas. Zazwyczaj są umieszczane na początku definicji funkcji, modułu lub klasy.
   W Pythonie używamy potrójnego cudzysłowia `(''' lub """)` do rozpoczęcia i zakończenia komentarza wielolinijkowego.

   Przykład:

   ```python
   '''
       To jest komentarz wielolinijkowy.
       Może zawierać wiele linii.
   '''
   ```

   ```python
   """
       To jest komentarz wielolinijkowy.
       Może zawierać wiele linii.
   """
   ```

   ```python
    '''
    To jest funkcja dodawania.
    '''
    def add(x, y):
        return x + y
   ```

# Nazewnictwo

Nazewnictwo (nazywanie) to proces nadawania odpowiednich nazw zmiennym, funkcjom, klasom i innym elementom w kodzie Pythona. Poprawne i opisowe nazwy są ważne, aby twój kod był czytelny, zrozumiały i łatwy do utrzymania. Oto kilka zasad dotyczących nazewnictwa w Pythonie:

1. **Znaki dozwolone: <br>**
   Nazwy mogą zawierać litery (a-z, A-Z), cyfry (0-9) i znak podkreślenia (\_). <br>
   Nazwy muszą zaczynać się od litery lub znaku podkreślenia. Nie mogą zaczynać się od cyfry.

2. **Styl nazewnictwa: <br>**
   W Pythonie stosuje się zasady konkretnego stylu nazewnictwa. Dwa najpopularniejsze style to:

   - **Styl snake_case:** W tym stylu wszystkie litery są małe, a słowa oddzielane są znakiem podkreślenia (\_). <br>
     Przykład: `my_variable`, `user_name`, `calculate_sum()`

   - **Styl CamelCase (również znany jako notacja wielbłądzia):** W tym stylu każde słowo rozpoczyna się wielką literą, a brak spacji lub znaków podkreślenia między słowami. <br>
     Przykład: `MyVariable`, `UserName`, `CalculateSum()`

3. **Zrozumiałe i opisowe nazwy: <br>**
   Staraj się nadawać nazwy, które dokładnie opisują przeznaczenie danej zmiennej, funkcji lub klasy. Unikaj nazw składających się z samych skrótów lub pojedynczych liter, które mogą być trudne do zrozumienia dla innych programistów.

4. **Unikanie słów kluczowych: <br>**
   Unikaj nadawania nazw, które są zarezerwowane jako słowa kluczowe w Pythonie, takie jak `if`, `while`, `for`, `def`, itp. Słowa kluczowe mają specjalne znaczenie w języku Python i nie mogą być używane jako nazwy zmiennych lub funkcji.

5. **Konwencje: <br>**
   Istnieje kilka konwencji nazewniczych, które są powszechnie stosowane w społeczności programistów Pythona, takie jak:

   - Zmienne i funkcje z małymi literami, oddzielone znakiem podkreślenia (snake_case).
   - Klasy z wielkimi literami, oddzielone wielkimi literami (CamelCase).
   - Stałe z dużymi literami, oddzielone znakiem podkreślenia (UPPER_CASE).

Przykłady poprawnych nazw w Pythonie:

```python
my_variable = 42
user_name = "John"
calculate_sum = lambda x, y: x + y

class MyClass:
    pass

def my_function():
    pass
```

Pamiętaj, że dobre praktyki nazewnicze pomagają innym programistom zrozumieć twój kod i ułatwiają utrzymanie go w przyszłości.

# Zmienne

1. **Deklaracja zmiennych: <br>**
   W Pythonie deklarujesz zmienne, przypisując im wartość. Nie musisz określać typu zmiennej podczas deklaracji, ponieważ Python jest językiem dynamicznie typowanym. Oznacza to, że typ zmiennej jest określany na podstawie przypisanej wartości.

   ```python
   x = 5  # zmienna całkowitoliczbowa (int)
   x_2 = -5  # zmienna całkowitoliczbowa (int)
   x_3 = 1_000_000  # zmienna całkowitoliczbowa (int) z podkreśleniami

   x, x_2 = 5, 10  # deklaracja dwóch zmiennych całkowitoliczbowych (int)

   y = 3.14  # zmienna zmiennoprzecinkowa (float)

   name = "John"  # zmienna typu napisowego (string)
   name = 'John'  # zmienna typu napisowego (string)
   name = """John
   zachowuje układ      tekstu
   """  # zmienna typu napisowego (string)
   name = '''John
   zachowuje układ      tekstu
   '''  # zmienna typu napisowego (string)

   is_true = True  # zmienna logiczna (bool)
   is_false = False  # zmienna logiczna (bool)

   is_empty = None  # zmienna pusta (None)

   is_byte = b"Hello"  # zmienna typu bajtowego (bytes)
   is_complex = 1 + 2j  # zmienna typu złożonego (complex)
   ```

2. **Stałe: <br>**
   W Pythonie nie ma specjalnego typu stałej. Możesz jednak uznać zmienną, której nie zmieniasz wartości w trakcie działania programu, za stałą. Konwencją jest, żeby nazwy zmiennych, które są traktowane jako stałe, zapisywać wielkimi literami, oddzielając je znakiem podkreślenia. Na przykład:

   ```python
   PI = 3.14159
   MAX_VALUE = 100
   ```

3. **Typy danych wbudowane: <br>**

   ```python
   my_list = [1, 2, 3, 4]  # lista, która może być zmieniona
   my_tuple = (1, 2, 3)  # krotka, która nie może być zmieniona
   my_dict = {"name": "John", "age": 25}  # słownik
   my_set = {1, 2, 3, 4}  # zbiór nieuporządkowany nie ma duplikatów

   numbers = range(1, 10)  # zakres
   ```

4. **Sprawdzanie typu zmiennej: <br>**

   ```python
   x = 5
   print(type(x))  # <class 'int'>

   name = "John"
   print(type(name))  # <class 'str'>

   is_true = True
   print(type(is_true))  # <class 'bool'>
   ```

5. **Narzucanie typu danych: <br>**
   W Pythonie możesz narzucić typ danych zmiennej, używając funkcji wbudowanej `int()`, `float()`, `str()`, `bool()`, `list()`, `tuple()`, `dict()`, `set()`, `range()`, `complex()`, `bytes()`, `bytearray()`, `frozenset()`, `memoryview()`. Na przykład:

   ```python
   x: int = 5
   y: float = 3.14
   name: str = "John"
   is_true: bool = True

    my_list: list = [1, 2, 3, 4]
    my_list_2: list[str] = ["John", "Bob", "Alice"] # itd.
    my_tuple: tuple = (1, 2, 3)
    my_dict: dict = {"name": "John", "age": 25}
    my_set: set = {1, 2, 3, 4}

    numbers: range = range(1, 10)

    is_byte: bytes = b"Hello"
    is_complex: complex = 1 + 2j

    is_byte_array: bytearray = bytearray(5)
    is_frozen_set: frozenset = frozenset({1, 2, 3, 4})
    is_memory_view: memoryview = memoryview(bytes(5))

   ```

   ```python
   def add(x: int, y: int) -> int:
       return x + y
   ```

   ```
    name = "John"
    number = 5
    number_2 = '5'

    result = name + number  # TypeError: can only concatenate str (not "int") to str

    result = name + str(number)  # John5
    result: str = name + str(number)  # John5

    result_2 = number + int(number_2)  # 10
    result_2: int = number + int(number_2)  # 10
   ```

# Operatory

1. **Operatory arytmetyczne: <br>**

   ```python
   x = 5
   y = 3

   print(x + y)  # 8
   print(x - y)  # 2
   print(x * y)  # 15
   print(x / y)  # 1.6666666666666667
   print(x % y)  # 2
   print(x ** y)  # 125
   print(x // y)  # 1
   ```

2. **Operatory porównania: <br>**

   ```python
   x = 5
   y = 3

   print(x == y)  # False
   print(x != y)  # True
   print(x > y)  # True
   print(x < y)  # False
   print(x >= y)  # True
   print(x <= y)  # False
   ```

3. **Operatory logiczne: <br>**

   ```python
   x = 5
   y = 3

   print(x > 3 and x < 10)  # True
   print(x > 3 or x < 4)  # True
   print(not(x > 3 and x < 10))  # False
   ```

4. **Operatory przypisania: <br>**

   ```python
   x = 5
   print(x)  # 5

   x += 3
   print(x)  # 8

   x -= 3
   print(x)  # 5

   x *= 3
   print(x)  # 15

   x /= 3
   print(x)  # 5.0

   x %= 3
   print(x)  # 2.0

   x //= 3
   print(x)  # 0.0

   x **= 3
   print(x)  # 0.0

    a = 4
    a // 3  # a = a // 2 = 1
    a **= 2  # a = a ** 2 = 16
    a <<= 2  # a = a << 2 = 64
    a >>= 2  # a = a >> 2 = 16
    a &= 2  # a = a & 2 = 0
    a |= 2  # a = a | 2 = 2
    a ^= 2  # a = a ^ 2 = 0
   ```

5. **Operatory kontenerów: <br>**

   ```python
   x = 5
   y = 3
   numbers = [1, 2, 3, 4, 5]

   print(x in numbers)  # True
   print(y in numbers)  # False
   print(x not in numbers)  # False
   print(y not in numbers)  # True
   ```

6. **Operatory tożsamości: <br>**

   ```python
   x = 5
   y = 3

   print(x is y)  # False
   print(x is not y)  # True
   ```

7. **Operatory bitowe: <br>**

   ```python
   x = 5
   y = 3

   print(a << b)  # przesunięcie bitowe w lewo 4 << 3 = 32
   print(a >> b)  # przesunięcie bitowe w prawo 4 >> 3 = 0
    print(a & b)  # operacja bitowa AND 4 & 3 = 0
   print(a | b)  # operacja bitowa OR 4 | 3 = 7
   print(a ^ b)  # operacja bitowa XOR 4 ^ 3 = 7
   print(~a)  # operacja bitowa NOT ~4 = -5
   ```

# Wypisywanie danych

1. **Funkcja print(): <br>**

   ```python
   print("Hello, world!") # Hello, world!
   print(10) # 10
   print("Liczba:", 5) # Liczba: 5
   print("Liczba: " + str(5)) # Liczba: 5
   print("Liczba:", 5, sep=" - ") # Liczba: - 5
   print("Liczba:", 5, end=" - ") # Liczba: 5 -
   print("Liczba:", 5, sep=" - ", end=" - ") # Liczba: - 5 -
   ```

2. **Używanie formatowania łańcuchów znaków: <br>**

   ```python
   name = "Alice"
   age = 25
   print("Nazywam się {} i mam {} lat.".format(name, age))

   # Od Pythona 3.6 można używać f-stringów
   print(f"Nazywam się {name} i mam {age} lat.")
   ```

3. **Używanie operatora , w print(): <br>**

   ```python
   name = "Bob"
   age = 30
   print("Nazywam się", name, "i mam", age, "lat.")
   ```

4. **Używanie sys.stdout.write(): <br>**
   ```python
   import sys
   sys.stdout.write("Hello, world!\n")
   ```
5. **Używanie znaku nowej linii, tabulatora i wyłączeanie znaków specjalnych używanych w pythonie: <br>**
   ```python
   print("\tLinia 1\nLinia 2\nLinia 3\nLinia \"4\"")
    #       Linia 1
    #Linia 2
    #Linia 3
    #Linia "4"
   ```
6. **Wypisywanie wartości z określoną precyzją: <br>**

   ```python
   pi = 3.14159265359
   print("Wartość π z dokładnością do 2 miejsc po przecinku: {:.2f}".format(pi)) # 3.14
   print(f"Wartość π z dokładnością do 2 miejsc po przecinku: {pi:.2f}") # 3.14

   name = "Alice"
   print(f"Nazywam się {name:.3s}") # Ali
   ```

7. **Wypisywanie wartości w innych systemach liczbowych: <br>**

   ```python
   number = 42
   print("Wartość w postaci binarnej:", bin(number))
   print("Wartość w postaci ósemkowej:", oct(number))
   print("Wartość w postaci szesnastkowej:", hex(number))

   print(int("0b1010", 2))  # konwersja z binarnego na dziesiętny - 10
   print(int("0o12", 8))  # konwersja z ósemkowego na dziesiętny - 10
   print(int("0xa", 16))  # konwersja z szesnastkowego na dziesiętny - 10
   ```

8. **Wypisywanie na standardowym wyjściu błędów: <br>**
   ```python
   import sys
   sys.stderr.write("To jest komunikat błędu!\n")
   ```
9. **Użycie separatora w print(): <br>**
   ```python
   numbers = [1, 2, 3, 4, 5]
   print(*numbers, sep=", ")
   ```

# Stringi

```python
string = "Ala ma kota"  # inicjalizacja zmiennej
print(string)  # print - czyli wypisanie tekstu # Ala ma kota
print(type(string))  # type - czyli sprawdzenie typu zmiennej
print(len(string))  # len - czyli długość tekstu
print(string[0])  # [0] - czyli pierwszy znak
print(string[:3])  # [:3] - czyli pierwsze 3 znaki
print(string[3:])  # [3:] - czyli od 3 znaku do końca
print(string[-3:])  # [-3:] - czyli od końca 3 znaki
print(string[:-3])  # [-3:] - czyli od końca 3 znaki
print(string[:3:2])  # [:3:2] - czyli pierwsze 3 znaki co drugi
print(string[::2])  # [::2] - czyli co drugi znak
print(string[::-1])  # [::-1] - czyli odwrócenie tekstu
print(string + string)  # + - czyli konkatenacja
print(string + " " + string)  # + - czyli konkatenacja>>>
print(string * 3)  # * - czyli powtórzenie tekstu
print(string.upper())  # upper - czyli zamiana na wielkie litery
print(string.lower())  # lower - czyli zamiana na małe litery

print(string.title()) # title - czyli zamiana na wielkie litery na początku każdego słowa
print(string.capitalize()) # capitalize - czyli zamiana na wielką literę na początku tekstu
print(string.replace("Ala", "Ola"))  # replace - czyli zamiana tekstu

string = "Ala ma kota, Ala ma psa, Ala ma rybki"
print(string.replace("Ala", "Ola")) # replace - czyli zamiana tekstu - tylko 1 raz
print(string.replace("Ala", "Ola", 2)) # replace 2 - czyli zamiana tekstu - tylko 2 razy
print(string.split(" ")) # split - czyli podział tekstu na listę tam gdzie jest spacja
print(string.split(" ")[0]) # split - czyli podział tekstu na listę i wybranie pierwszego elementu
print(string.split(" ")[1]) # split - czyli podział tekstu na listę i wybranie drugiego elementu

string = "Ala ma kota"
print(string.find("Ala"))  # find - czyli wyszukanie tekstu
print(string.find("Ala", 5))  # find - czyli wyszukanie tekstu od 5 znaku
print(string.find("Ala", 0, 11)) # find - czyli wyszukanie tekstu od 5 do 10 znaku
print(string.find("Ala", 0, 11) != -1) # find - czyli wyszukanie tekstu od 5 do 10 znaku i sprawdzenie czy znaleziono
print("Ala" in string)  # in - czyli sprawdzenie czy tekst jest w tekście
print("Ala" not in string) # not in - czyli sprawdzenie czy tekst nie jest w tekście

print(string.startswith("Ala")) # startswith - czyli sprawdzenie czy tekst zaczyna się od tekstu
print(string.endswith("Ala")) # endswith - czyli sprawdzenie czy tekst kończy się na tekst
print(string.isalpha()) # isalpha - czyli sprawdzenie czy tekst składa się tylko z liter
print(string.isdigit()) # isdigit - czyli sprawdzenie czy tekst składa się tylko z cyfr
print(string.isalnum()) # isalnum - czyli sprawdzenie czy tekst składa się tylko z liter i cyfr
print(string.islower()) # islower - czyli sprawdzenie czy tekst składa się tylko z małych liter
print(string.isupper()) # isupper - czyli sprawdzenie czy tekst składa się tylko z wielkich liter
print(string.istitle()) # istitle - czyli sprawdzenie czy tekst składa się tylko z wielkich liter na początku słów
print(string.isspace()) # isspace - czyli sprawdzenie czy tekst składa się tylko z białych znaków
print(string.isdecimal()) # isdecimal - czyli sprawdzenie czy tekst składa się tylko z cyfr
print(string.isnumeric()) # isnumeric - czyli sprawdzenie czy tekst składa się tylko z cyfr
print(string.isidentifier()) # isidentifier - czyli sprawdzenie czy tekst jest poprawnym identyfikatorem

print(string.isprintable()) # isprintable - czyli sprawdzenie czy tekst jest drukowalny
print(string.isascii())  # isascii - czyli sprawdzenie czy tekst jest ASCII

print(string.count("Ala"))  # count - czyli zliczenie wystąpień tekstu
print(string.count("Ala", 0, 11)) # count - czyli zliczenie wystąpień tekstu od 1 do 10 znaku
print(string.index("Ala"))  # index - czyli pierwsze wystąpienie tekstu

print(string.index("Ala", 0, 11)) # index - czyli wyszukanie tekstu od 1 do 10 znaku
print(string.rindex("Ala"))  # rindex - czyli wyszukanie tekstu od końca

print(string.zfill(20)) # zfill - czyli wypełnienie tekstu zerami z lewej strony do 20 znaków
print(string.center(20)) # center - czyli wypełnienie tekstu spacjami z lewej i prawej strony do 20 znaków

print(string.ljust(20)) # ljust - czyli wypełnienie tekstu spacjami z lewej strony
print(string.rjust(20)) # rjust - czyli wypełnienie tekstu spacjami z prawej strony

# strip - czyli usunięcie białych znaków z lewej i prawej strony
string = " Ala ma kota "
print(string.strip())
print(string.lstrip())  # lstrip - czyli usunięcie białych znaków z lewej strony
print(string.rstrip())  # rstrip - czyli usunięcie białych znaków z prawej strony
print(string.strip(" Ala"))# strip - czyli usunięcie tekstu z lewej i prawej strony

string = "Ala ma kota"
print(string.expandtabs(20))# expandtabs - czyli zamiana tabulatorów na spacje
print(string.encode())  # encode - czyli zamiana tekstu na bajty
print(string.encode().decode())  # decode - czyli zamiana bajtów na tekst

join_string = " ".join(["Ala", "ma", "kota"]) # join - czyli połączenie tekstu z listy
# Ala ma kota
join_string = "-"
print(join_string.join(["Ala", "ma", "kota"])) # join - czyli połączenie tekstu z listy
# Ala-ma-kota

string = "Ala "
string2 = "ma kota"
print(string + string2)  # + - czyli konkatenacja tekstu
print(" ".join([string, string2]))  # join - czyli połączenie tekstu z listy
```

# Instrukcje warunkowe

1. **Instrukcja if: <br>**
   ```python
   x = 5
   if x > 0:
       print("x jest większe od zera")
   ```
2. **Instrukcja if z blokiem else: <br>**
   ```python
   x = 5
   if x > 0:
       print("x jest większe od zera")
   else:
       print("x jest mniejsze lub równe zeru")
   ```
3. **Instrukcja if z blokami elif i else: <br>**
   ```python
   x = 5
   if x > 0:
       print("x jest większe od zera")
   elif x < 0:
       print("x jest mniejsze od zera")
   else:
       print("x jest równe zeru")
   ```
4. **Instrukcje warunkowe w jednej linii: <br>**
   ```python
   x = 5
   result = "Dodatnie" if x > 0 else "Ujemne lub równe zero"
   print(result)
   ```
5. **Instrukcja pass: <br>**
   ```python
   x = 5
   if x > 0:
       pass  # Nic nie robimy - przydatne przy tworzeniu szkieletu kodu
   else:
       print("x jest mniejsze lub równe zeru")
   ```
6. **Instrukcja break i continue w pętlach: <br>**
   Break - przerywa działanie pętli <br>
   Continue - przerywa działanie aktualnej iteracji i przechodzi do kolejnej <br>

   ```python
   numbers = [1, 2, 3, 4, 5]
   for num in numbers:
       if num == 3:
           break
       print(num)
    1
    2
   ```

   ```python
   numbers = [1, 2, 3, 4, 5]
   for num in numbers:
       if num == 3:
           continue
       print(num)
    1
    2
    4
    5
   ```

7. **Truthy (prawdziwe) i Falsy (fałszywe): <br>**
   W Pythonie występują wartości Truthy (prawdziwe) i Falsy (fałszywe), które określają wynik warunków logicznych. Wartości Falsy obejmują False, None, zero liczbowe, puste sekwencje i kolekcje, oraz obiekty, które zwracają False lub 0 w swoich metodach bool() lub len(). Wszystkie inne wartości są uznawane za Truthy.

   Przykłady zmiennych różnych rodzajów i ich wartości Truthy/Falsy:

   ```python
   bool_var = True  # Truthy
   int_var = 0  # Falsy
   float_var = 3.14  # Truthy
   str_var = "Hello"  # Truthy
   list_var = []  # Falsy
   tuple_var = (1, 2, 3)  # Truthy
   dict_var = {}  # Falsy
   set_var = set()  # Falsy
   none_var = None  # Falsy

   if bool_var:
      print("bool_var jest Truthy")

   if int_var:
      print("int_var jest Falsy")

   if float_var:
      print("float_var jest Truthy")

   if str_var:
      print("str_var jest Truthy")

   if list_var:
      print("list_var jest Falsy")

   if tuple_var:
      print("tuple_var jest Truthy")

   if dict_var:
      print("dict_var jest Falsy")

   if set_var:
      print("set_var jest Falsy")

   if none_var:
      print("none_var jest Falsy")
   ```

# Pętle

1. **Pętla for: <br>**
   ```python
   numbers = [1, 2, 3, 4, 5]
   for num in numbers:
       print(num)
   ```
   ```python
   numbers = [1, 2, 3, 4, 5]
   for index, num in enumerate(numbers):
       print(f"Index: {index}, Wartość: {num}")
   ```
   ```python
   word = "Python"
   for char in word:
       print(char)
   ```
2. **Pętla while: <br>**
   ```python
   x = 0
   while x < 5:
        print(x)
        x += 1
   ```
   ```python
   x = 0
   while True:
        if x == 3:
             break
        print(x)
        x += 1
   ```
   ```python
   x = 0
   while x < 5:
        x += 1
        if x == 3:
             continue
        print(x)
   ```
3. **Pętla do-while (nie jest dostępna natywnie w Pythonie, ale można ją zasymulować): <br>**
   ```python
   x = 0
   while True:
        print(x)
        x += 1
        if x >= 5:
             break
   ```
4. **Pętla for-else: <br>**

   ```python
   numbers = [1, 2, 3, 4, 5]
   for num in numbers:
        print(num)
   else:
        print("Pętla zakończona")
   ```

   ```python
   numbers = [1, 2, 3, 4, 5]
   for num in numbers:
        if num == 3:
             break
        print(num)
   else:
        print("Pętla zakończona")
   ```

5. **Funkcja range(start, stop, step) w Pythonie jest często używana do generowania sekwencji liczb. Oto kilka przykładów użycia funkcji range wraz z oczekiwanymi wynikami: <br>**
   ```python
   for i in range(5):
        print(i)
    1
    2
    3
    4
    5
   ```
   ```python
   for i in range(2, 8):
        print(i)
    2
    3
    4
    5
    6
    7
   ```
   ```python
   for i in range(1, 10, 2):
       print(i)
   1
   3
   5
   7
   9
   ```
   ```python
   my_list = list(range(5))
   print(my_list)
   [0, 1, 2, 3, 4]
   ```

Indeksowanie:

Możesz używać indeksowania w pętlach do dostępu do poszczególnych elementów w sekwencjach, takich jak listy czy krotki.
Przykład iteracji z użyciem indeksowania:
python
Copy code
fruits = ["apple", "banana", "cherry"]
for i in range(len(fruits)):
print(fruits[i])

6. **Pętle zagnieżdżone: <br>**

   ```python
   for i in range(3):
        for j in range(2):
             print(i, j)
   ```

7. **Pętla nieskończona: <br>**
   ```python
   while True:
        answer = input("Wprowadź coś: ")
        if answer == "quit":
             break
        else:
             print("Wprowadzono:", answer)
   ```
8. **Iteracja po indeksach: <br>**
   UWAGA - podczas iteracji nie nalerzy modyfikować listy, po której się iteruje, może to prowadzić do nieprzewidywalnych rezultatów, rozwiązaniem jest skopiowanie listy i modyfikowanie kopii :).

   ```python
   fruits = ["apple", "banana", "cherry"]
   for i in range(len(fruits)):
         print(fruits[i])
   ```

9. **Iteracja po kolekcjach: <br>**
   ```python
   fruits = ["apple", "banana", "cherry"]
   for fruit in fruits:
           print(fruit)
   ```
10. **Iteracja po słownikach: <br>**
    ```python
    person = {"name": "John", "age": 30, "city": "New York"}
    for key in person:
         print(key, person[key])
    ```
    ```python
    person = {"name": "John", "age": 30, "city": "New York"}
    for key, value in person.items():
         print(key, value)
    ```
11. **Iteracja po zbiorach: <br>**
    ```python
    my_set = {"apple", "banana", "cherry"}
    for item in my_set:
         print(item)
    ```
12. **Iteracja po plikach: <br>**
    ```python
    with open("file.txt") as f:
         for line in f:
             print(line)
    ```
13. **Enumeracja: <br>**
    ```python
    fruits = ["apple", "banana", "cherry"]
    for index, fruit in enumerate(fruits):
         print(index, fruit)
    ```
14. **Iteracja po dwóch lub więcej sekwencjach: <br>**
    ```python
    numbers = [1, 2, 3]
    letters = ["a", "b", "c"]
    for number, letter in zip(numbers, letters):
         print(number, letter)
    ```
15. **Iteracja po sekwencjach w odwrotnej kolejności: <br>**
    ```python
    numbers = [1, 2, 3]
    for number in reversed(numbers):
         print(number)
    ```
16. **Iteracja po sekwencjach w kolejności posortowanej: <br>**
    ```python
    numbers = [3, 1, 2]
    for number in sorted(numbers):
         print(number)
    ```
17. **Iteracja po sekwencjach w kolejności posortowanej w odwrotnej kolejności: <br>**
    ```python
    numbers = [3, 1, 2]
    for number in sorted(numbers, reverse=True):
         print(number)
    ```
18. **Iteracja po sekwencjach w kolejności posortowanej według klucza: <br>**
    ```python
    numbers = [3, 1, 2]
    for number in sorted(numbers, key=lambda x: x % 2 == 0):
         print(number)
    ```
19. **Iteracja po sekwencjach w kolejności posortowanej według klucza w odwrotnej kolejności: <br>**
    ```python
    numbers = [3, 1, 2]
    for number in sorted(numbers, key=lambda x: x % 2 == 0, reverse=True):
         print(number)
    ```
20. **Iteracja po sekwencjach w kolejności posortowanej według wielu kluczy: <br>**
    ```python
    numbers = [3, 1, 2]
    for number in sorted(numbers, key=lambda x: (x % 2 == 0, x)):
         print(number)
    ```
21. **Filter: <br>**
    Filter jest wbudowaną funkcją, która filtruje elementy z sekwencji na podstawie funkcji. <br>
    ```python
    numbers = [1, 2, 3, 4, 5, 6]
    even_numbers = filter(lambda x: x % 2 == 0, numbers)
    for number in even_numbers:
         print(number)
    ```
22. **Map: <br>**
    Map jest wbudowaną funkcją, która mapuje / sortuje elementy z sekwencji na podstawie funkcji. <br>

    ```python
    numbers = [1, 2, 3, 4, 5, 6]
    squared_numbers = map(lambda x: x ** 2, numbers)
    for number in squared_numbers:
         print(number)
    ```

23. **List comprehension: <br>**
    List comprehension jest wbudowaną funkcją, która tworzy listę na podstawie innej sekwencji. <br>

    ```python
    numbers = [1, 2, 3, 4, 5, 6]
    even_numbers = [x for x in numbers if x % 2 == 0]
    for number in even_numbers:
         print(number)

    lub

    numbers = [x for x in range(10)]
    print(numbers) # [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
    ```

24. **Wyrażenia lambda: <br>**
    Wyrażenia lambda są anonimowymi funkcjami, które są zdefiniowane bez nazwy. <br>
    ```python
    add = lambda x, y: x + y
    print(add(1, 2))
    ```

# Funkcjie

1. **Funkcje: <br>**
   Funkcje są podstawowym elementem programowania i służą do grupowania powtarzalnego kodu w logiczne bloki. <br>
   Funkcje umożliwiają wielokrotne wykorzystanie kodu, zwiększając czytelność, modularność i łatwość utrzymania programu. <br>
   Ogólna składnia deklaracji funkcji w Pythonie wygląda następująco: <br>

   ```python
   def nazwa_funkcji(argumenty):
       # Kod funkcji
       return wynik
   ```

   ```python
   def: Słowo kluczowe def służy do definiowania funkcji.
   nazwa_funkcji: Nazwa funkcji powinna być unikalna i opisowa.
   argumenty: Funkcje mogą przyjmować zero lub więcej argumentów. Argumenty są opcjonalne i oddzielane przecinkami.
   return: Instrukcja return jest używana do zwracania wartości z funkcji. Jeśli funkcja nie zwraca wartości, może zostać pominięta lub użyta sama return bez żadnej wartości.
   ```

   Przykład prostej funkcji, która dodaje dwie liczby: <br>

   ```python
   def dodaj(a, b):
       suma = a + b
       return suma

   wynik = dodaj(3, 5)
   print(wynik)  # Wyświetli: 8
   ```

2. **Argumenty funkcji: <br>**
   Funkcje mogą przyjmować różne rodzaje argumentów, takie jak: <br>

   - **Argumenty pozycyjne:** Argumenty, które są przekazywane w tej samej kolejności, w jakiej są zdefiniowane w deklaracji funkcji.
   - **Argumenty domyślne:** Argumenty, które mają wartości domyślne i są używane, jeśli nie zostaną przekazane żadne inne wartości.
   - **Argumenty kluczowe:** Argumenty, które są przekazywane z wyraźnym podaniem ich nazw w postaci "klucz=wartość".
   - **Argumenty zmiennych długości:** Argumenty, które umożliwiają przekazanie dowolnej liczby argumentów pozycyjnych lub argumentów kluczowych.
     Przykład funkcji z różnymi rodzajami argumentów: <br>

   ```python
   def przywitanie(imie, wiek=30, *args, **kwargs):
       print(f"Witaj, {imie}!")
       print(f"Masz {wiek} lat.")

       print("Dodatkowe argumenty pozycyjne:")
       for arg in args:
           print(arg)

       print("Dodatkowe argumenty kluczowe:")
       for key, value in kwargs.items():
           print(f"{key}: {value}")

   przywitanie("Jan", 25, "arg1", "arg2", arg3="wartosc3", arg4="wartosc4")
   ```

   Wynik: <br>

   ```yaml
   Witaj, Jan!
   Masz 25 lat.
   Dodatkowe argumenty pozycyjne:
   arg1
   arg2
   Dodatkowe argumenty kluczowe:
   arg3: wartość3
   arg4: wartość4
   ```

   **\*args: <br>**
   Pozwala na przekazanie dowolnej liczby argumentów pozycyjnych do funkcji. <br>
   Argumenty przekazane jako \*args są traktowane jako krotka wewnątrz funkcji. <br>
   Można je wykorzystać do obsługi różnej liczby argumentów, które nie są znane z góry. <br>
   Przykład: <br>

   ```python
   def funkcja(*args):
      for arg in args:
         print(arg)

   funkcja(1, 2, 3, 4, 5)
   ```

   \***\*kwargs: <br>**
   Pozwala na przekazanie dowolnej liczby argumentów kluczowych do funkcji. <br>
   Argumenty przekazane jako \*\*kwargs są traktowane jako słownik wewnątrz funkcji, gdzie klucze są nazwami argumentów, a wartości to przypisane do nich wartości. <br>
   Można je wykorzystać do obsługi różnych argumentów kluczowych, które nie są znane z góry. <br>
   Przykład: <br>

   ```python
   def funkcja(**kwargs):
      for key, value in kwargs.items():
         print(f"{key}: {value}")

   funkcja(imie="Jan", wiek=25, zawod="programista")
   ```

   Argumenty \*args i \*\*kwargs mogą być również używane razem w jednej funkcji, co pozwala na elastyczne przekazywanie argumentów zarówno pozycyjnych, jak i kluczowych. <br>
   Przykład: <br>

   ```python
   def funkcja(*args, **kwargs):
      for arg in args:
         print(arg)

      for key, value in kwargs.items():
         print(f"{key}: {value}")

   funkcja(1, 2, 3, imie="Jan", wiek=25)
   ```

3. **Zwracanie wartości z funkcji: <br>**
   Funkcje w Pythonie mogą również zwracać wiele wartości, używając krotek lub innych struktur danych. <br>
   Możesz przypisać zwracane wartości do zmiennych i używać ich w dalszej części programu. <br>
   Przykład funkcji zwracającej wiele wartości: <br>

   ```python
   def obliczenia(a, b):
       suma = a + b
       roznica = a - b
       iloczyn = a * b
       return suma, roznica, iloczyn

   x, y, z = obliczenia(5, 3)
   print(x, y, z)  # Wyświetli: 8 2 15
   ```

   Brak zwracania wartości: <br>

   ```python
     def powitanie(imie):
        print(f"Witaj, {imie}!")
        return
   lub
       def powitanie(imie):
         print(f"Witaj, {imie}!")
   ```

   To tylko kilka podstawowych informacji o funkcjach w Pythonie. <br>
   Istnieje wiele bardziej zaawansowanych funkcji i technik, takich jak funkcje lambda, rekurencja, dekoratory i wiele innych, które można zastosować w celu tworzenia bardziej zaawansowanych programów. <br>

4. **Zmeinne w funkcjach - Adnotacja typów: <br>**
   Poniższy przykład daje nam co funkcja przyjmuje i co zwraca - ludzie lepiej rozumieją kod, który jest czytelny, + podczas pisania funkcji zyskujemy podpowiedzi od IDE i ułatwia debugowanie. <br>

   ```python
   def funkcja(imie: str, wiek: int) -> str:
      return f"Witaj, {imie}! Masz {wiek} lat."
   ```

5. ** / i \* <br>**
   W Pythonie 3.8 wprowadzono nowe składnie, która pozwala na deklarowanie argumentów pozycyjnych, standardowych i kluczowych. <br>
   Argumenty pozycyjne muszą być przekazane na podstawie ich pozycji, argumenty standardowe mogą być przekazane na podstawie ich pozycji lub nazwy, a argumenty kluczowe muszą być przekazane na podstawie ich nazwy. <br>
   Aby zadeklarować argumenty pozycyjne, użyj ukośnika (/) w deklaracji funkcji. <br>
   Aby zadeklarować argumenty kluczowe, użyj gwiazdki (\*) w deklaracji funkcji. <br>
   Aby zadeklarować argumenty pozycyjne, standardowe i kluczowe, użyj zarówno ukośnika (/) jak i gwiazdki (\*) w deklaracji funkcji. <br>
   **Wyszstko przed ukośnikiem (/) musi być przekazane na podstawie ich pozycji, a wszystko przed gwiazdką (\*) musi być przekazane na podstawie ich nazwy. <br>**
   Oto kompletny kod z przykładami i wyjaśnieniem dla deklaracji funkcji pos_only_arg, kwd_only_arg i combined_example: <br>

   ```python
   def pos_only_arg(arg, arg2, /):
       """
       Przykład funkcji z argumentami pozycyjnymi.
       """
       print(arg, arg2)

   def kwd_only_arg(*, arg):
       """
       Przykład funkcji z argumentem kluczowym.
       """
       print(arg)

   def combined_example(pos_only, /, standard, *, kwd_only):
       """
       Przykład funkcji z argumentami pozycyjnymi, standardowymi i kluczowymi.
       """
       print(pos_only, standard, kwd_only)
   Teraz możemy przetestować te funkcje:

   python

   pos_only_arg(1, 2)
   # Wyświetli: 1 2
   W powyższym przykładzie przekazujemy argumenty 1 i 2 na podstawie ich pozycji.

   python

   kwd_only_arg(arg=3)
   # Wyświetli: 3
   W tym przykładzie przekazujemy argument 3 jako argument kluczowy, podając jego nazwę arg.

   python

   combined_example(1, 2, kwd_only=3)
   # Wyświetli: 1 2 3
   W ostatnim przykładzie przekazujemy 1 i 2 jako argumenty pozycyjne, a 3 jako argument kluczowy o nazwie kwd_only.

   Znak ukośnika (/) w deklaracji funkcji pos_only_arg oznacza, że argumenty po nim muszą być przekazane na podstawie ich pozycji. Asterisk (*) przed arg w deklaracji funkcji kwd_only_arg oznacza, że arg musi być przekazane jako argument kluczowy. W deklaracji funkcji combined_example używamy zarówno ukośnika jak i asteriska, aby rozróżnić argumenty pozycyjne, standardowe i kluczowe.

   NP.
   def print(self, *args, sep=' ', end='\n', file=None):
   ```

6. **Rekurencja: <br>**
   Rekurencja to technika, w której funkcja wywołuje samą siebie. <br>
   Jest przydatna do rozwiązywania problemów, które mają strukturę powtarzającą się. <br>
   Przykład: <br>

   ```python
   def oblicz_silnie(n):
      if n == 0:
         return 1
      else:
         return n * oblicz_silnie(n - 1)

   wynik = oblicz_silnie(5)
   print(wynik)  # Wyświetli: 120
   ```

7. **Wewnętrzne funkcje: <br>**
   Możesz zdefiniować funkcję wewnątrz innej funkcji. <br>
   Wewnętrzna funkcja ma dostęp do zmiennych lokalnych z funkcji zewnętrznej. <br>
   Przykład: <br>

   ```python
   def zewnetrzna():
      x = 2

      def wewnetrzna(y):
         return x + y

      return wewnetrzna

   funkcja_wewnetrzna = zewnetrzna()
   wynik = funkcja_wewnetrzna(3)
   print(wynik)  # Wyświetli: 5
   ```

# Input

1. **input()** - funkcja, która pozwala na wprowadzenie danych przez użytkownika. <br>
   Funkcja input() zwraca wartość typu str. <br>
   Przykład: <br>

   ```python
   user_input: str = input('Enter your name: ')
   print(f'Hello, {user_input}!')
   ```

   ```python
   a = input('Enter a number: ')
   b = input('Enter another number: ')
   print(f'The sum of {a} and {b} is {a + b}.')
   # Wyświetli: The sum of 1 and 2 is 12.
   print(f'The sum of {a} and {b} is {int(a) + int(b)}.')
   # Wyświetli: The sum of 1 and 2 is 3.
   # Wświetli błąd, jeśli użytkownik wprowadzi nieprawidłowe dane.

   ```

# Obsługa błędów

1. **try, except, else, finally** - instrukcje, które pozwalają na obsługę błędów. <br>
   Przykład: <br>

   ```python
   try:
      x = int(input('Podaj liczbę: '))
      result = 10 / x
      print('Wynik: ', result)
   except ValueError:
      print('Błąd! Podano niepoprawną liczbę.')
   except ZeroDivisionError:
      print('Błąd! Nie można dzielić przez zero.')
   ```

   W tym przykładzie próbujemy podzielić liczbę 10 przez liczbę wprowadzoną przez użytkownika. <br>
   Jeśli użytkownik poda niepoprawną liczbę (np. tekst zamiast liczby), zostanie wygenerowany wyjątek ValueError. <br>
   Jeśli użytkownik poda zero, zostanie wygenerowany wyjątek ZeroDivisionError. <br>
   Oba te wyjątki są obsługiwane przez osobne bloki except, które wyświetlają odpowiednie komunikaty o błędach. <br>
   Dodatkowo, można użyć bloku else po blokach except, który zostanie wykonany tylko wtedy, gdy nie zostanie zgłoszony żaden wyjątek: <br>

   ```python
   try:
      # Kod, w którym może wystąpić wyjątek
      # ...
   except ExceptionType:
      # Kod obsługi wyjątku
      # ...
   else:
      # Kod, który zostanie wykonany, jeśli nie zostanie zgłoszony żaden wyjątek
      # ...
   ```

   Można również użyć bloku finally, który zawiera kod, który zawsze zostanie wykonany, niezależnie od tego, czy wystąpił wyjątek czy nie: <br>

   ```python
   try:
      # Kod, w którym może wystąpić wyjątek
      # ...
   except ExceptionType:
      # Kod obsługi wyjątku
      # ...
   finally:
      # Kod, który zawsze zostanie wykonany
      # ...
   ```

   Obsługa błędów w Pythonie pozwala kontrolować i reagować na potencjalne błędy podczas wykonywania kodu, co przyczynia się do bardziej niezawodnych i odpornych programów.

   ```python
   try:
      x = int(input('Podaj liczbę: '))
      result = 10 / x
      print('Wynik: ', result)
   except ValueError:
      print('Błąd! Podano niepoprawną liczbę.')
   except ZeroDivisionError:
      print('Błąd! Nie można dzielić przez zero.')
   else:
      print('Nie wystąpił żaden błąd.')
   finally:
      print('Koniec programu.')
   ```

   BĄDŹ JAK NAJBARDZIEJ KONKRETNY W OBSŁUDZE BŁĘDÓW
   UNIKIAJ PONIŻSZYCH KONSTRUKCJI W KOŃCOWYM KODZIE

   ```python
   try:
      number = int(input('Podaj liczbę: '))
      print('Liczba o której myślałeś to: ', number)
   except Exception as e:
      print(e)
   ```

   Prosta obsługa błędów:

   ```python
   def do_math():
      try:
         x = int(input('Podaj liczbę: '))
         result = 10 / x
         print('Wynik: ', result)
      except ValueError:
         print('Błąd! Podano niepoprawną liczbę.')
         do_math()
      except ZeroDivisionError:
         print('Błąd! Nie można dzielić przez zero.')
         do_math()
      except Exception as e:
         print('Coś poszło nie tak: ', e)

   do_math()
   ```

2. **Tworzenie własnych wyjątków: <br>**

   ```python
   class MyException(Exception):
      pass

   try:
      raise MyException('To jest mój wyjątek.')
   except MyException as e:
      print(e)

   lub

   class MyCustomError(Exception):
      pass

   def my_function(value):
      if not isinstance(value, int):
         raise MyCustomError("Oczekiwano wartości całkowitej.")

   try:
      x = "abc"
      my_function(x)
   except MyCustomError as e:
      print("Wystąpił błąd:", e)

   lub

   def my_function(value):
      if not isinstance(value, int):
         raise Exception("Oczekiwano wartości całkowitej.")

   try:
      x = "abc"
      my_function(x)
   except Exception as e:
      print("Wystąpił błąd:", e)

   lub
   # MyCustomError - jakaś nazwa wyjątku wcześniej zdefiniowanego w pythonie
   def my_function(value):
      if not isinstance(value, int):
         raise MyCustomError("Oczekiwano wartości całkowitej.")

   try:
      x = "abc"
      my_function(x)
   except Exception as e:
      print("Wystąpił błąd:", e)
   ```

# Pakiety i moduły

1. **Moduły: <br>**
   Moduł w Pythonie to plik zawierający kod Pythona, który można importować i wykorzystywać w innych programach. Moduły pozwalają na organizację kodu, dzielenie go na logiczne części oraz ułatwiają ponowne wykorzystanie kodu. Każdy plik z rozszerzeniem .py może być traktowany jako moduł.

   ```python
   # mymodul.py
   def greet(name):
      print(f"Hello, {name}!")

   def add(a, b):
      return a + b
   ```

   ```python
   # main.py
   import mymodul

   mymodul.greet("John")  # Wywołanie funkcji greet z modułu mymodul
   result = mymodul.add(3, 5)  # Wywołanie funkcji add z modułu mymodul

   print(result)
   ```

   ```python
   # main.py
   import mymodul as mm

   mm.greet("John")  # Wywołanie funkcji greet z modułu mymodul
   result = mm.add(3, 5)  # Wywołanie funkcji add z modułu mymodul

   print(result)
   ```

   ```python
   # main.py
   from mymodul import greet, add

   greet("John")  # Wywołanie funkcji greet z modułu mymodul
   result = add(3, 5)  # Wywołanie funkcji add z modułu mymodul

   print(result)
   ```

2. **Pakiety: <br>**
   Pakiet w Pythonie to folder zawierający moduły i inne podpakiey. Pozwala na hierarchiczną organizację kodu i unikanie kolizji nazw. Pakiety są wykorzystywane, gdy kod staje się bardziej rozbudowany i potrzebujemy podzielić go na logiczne części.

   ```python
   # mypackage/
   #    |- mymodule1.py
   #    |- mymodule2.py
   ```

   ```python
   # main.py
   from mypackage import mymodule1, mymodule2

   mymodule1.function1()  # Wywołanie funkcji function1 z modułu mymodule1
   mymodule2.function2()  # Wywołanie funkcji function2 z modułu mymodule2
   ```

   ```python
   # main.py
   from mypackage import mymodule1 as mm1, mymodule2 as mm2

   lub

   import mypackage * # importuje wszystkie moduły z pakietu
   ```

# Enum

1. **Enum: <br>**
   Enum to moduł wbudowany, który umożliwia definiowanie i używanie enumeracji. Enumeracja jest typem danych, który definiuje zbiór nazwanych wartości, które są traktowane jako stałe. Enumeracja ułatwia pracę z zestawem powiązanych stałych, zapewniając im znaczące nazwy i wartości.

   ```python
   from enum import Enum

   class Color(Enum):
      RED = 1
      GREEN = 2
      BLUE = 3

   print(Color.RED)  # Output: Color.RED
   print(Color.RED.value)  # Output: 1

   # Porównywanie wartości enum
   color1 = Color.RED
   color2 = Color.GREEN
   print(color1 == color2)  # Output: False

   # Iterowanie po wartościach enum
   for color in Color:
      print(color)

   # Sprawdzanie czy wartość należy do enum
   value = 2
   if value in Color:
      print(f'{value} należy do Color')
   else:
      print(f'{value} nie należy do Color')
   ```

   Enumy są przydatne w przypadkach, gdy potrzebujemy definiować zestaw powiązanych stałych i chcemy zapewnić czytelność i spójność w naszym kodzie.

# Porównywanie liczby zmiennoprzecinkowych

**Porównywanie liczb zmiennoprzecinkowych (float) jest nieco bardziej skomplikowane niż porównywanie liczb całkowitych. Ze względu na sposób reprezentacji liczb zmiennoprzecinkowych w komputerze, mogą wystąpić pewne problemy z dokładnością, co może prowadzić do nieoczekiwanych wyników porównań.**

1. **Porównywanie z tolerancją (epsilon): Zamiast porównywać liczby bezpośrednio, można użyć pewnego marginesu tolerancji (epsilon) do określenia, jak blisko dwie liczby muszą być, aby zostały uznane za równe.**

   ```python
   def are_equal(a, b):
       epsilon = 0.0001
       return abs(a - b) < epsilon

   result = are_equal(0.1 + 0.2, 0.3)

   print(result)  # True
   ```

2. **Zaokrąglanie: Innym podejściem jest zaokrąglanie liczb zmiennoprzecinkowych do określonej liczby miejsc po przecinku i porównywanie zaokrąglonych wartości.**

   ```python
   def are_equal_rounded(a, b, decimal_places=5):
       rounded_a = round(a, decimal_places)
       rounded_b = round(b, decimal_places)
       return rounded_a == rounded_b

   result = are_equal_rounded(0.1 + 0.2, 0.3)

   print(result)  # True
   ```

3. **Użycie modułu math.isclose(): Python dostarcza moduł math, który zawiera funkcję isclose(), która porównuje dwie liczby zmiennoprzecinkowe z uwzględnieniem tolerancji.**

   ```python
   import math

   result = math.isclose(0.1 + 0.2, 0.3)

   print(result)  # True
   ```

   Funkcja isclose() automatycznie uwzględnia tolerancję i jest bardziej zaawansowanym sposobem porównywania liczb zmiennoprzecinkowych.

# if **name** == "**main**"

if **name** == "**main**" jest konstrukcją warunkową używaną w Pythonie, która sprawdza, czy aktualnie wykonywany skrypt jest głównym skryptem (czyli bezpośrednio uruchomionym) czy modułem importowanym przez inny skrypt.

Kiedy uruchamiasz skrypt Pythona, interpreter ustawia specjalną zmienną o nazwie **name** na wartość "**main**" dla skryptu, który jest bezpośrednio uruchamiany. Natomiast dla modułów importowanych przez inne skrypty **name** przyjmuje wartość nazwy modułu.

W praktyce, umieszczając kod w bloku if **name** == "**main**", możesz kontrolować wykonanie kodu w zależności od tego, czy skrypt jest uruchamiany bezpośrednio czy importowany jako moduł.

Przykład:

```python
def main():
    # Kod, który zostanie wykonany, gdy skrypt jest uruchamiany bezpośrednio
    print("Ten kod zostanie wykonany tylko wtedy, gdy skrypt jest uruchamiany bezpośrednio")

# Wywołanie funkcji main, jeśli skrypt jest uruchamiany bezpośrednio
if __name__ == "__main__":
    main()
```

W tym przykładzie, gdy uruchamiasz ten skrypt bezpośrednio, zostanie wywołana funkcja main(). Jednak jeśli ten skrypt jest importowany przez inny skrypt, kod w bloku if **name** == "**main**" nie zostanie wykonany, a funkcja main() nie będzie automatycznie wywoływana.

To jest przydatne w przypadku, gdy chcesz mieć kontrolę nad tym, które fragmenty kodu są wykonywane tylko wtedy, gdy skrypt jest uruchamiany bezpośrednio, a które są dostępne dla innych skryptów jako moduł.

# Zakresy zmiennych w Pythonie

1. **Zakres globalny: <br>** To jest najwyższy poziom zakresu, w którym zmienne są zdefiniowane poza jakimikolwiek blokami kodu. Zmienne zdefiniowane w zakresie globalnym są dostępne we wszystkich częściach kodu.

   Przykład:

   ```python
   x = 10  # Zmienna globalna

   def func():
       print(x)  # Możemy odwołać się do zmiennej globalnej wewnątrz funkcji

   func()  # Wywołanie funkcji
   ```

2. **Zakres lokalny: <br>** To jest zakres zdefiniowany wewnątrz bloku kodu, takiego jak funkcja, pętla czy instrukcja warunkowa. Zmienne zdefiniowane w zakresie lokalnym są widoczne tylko wewnątrz tego bloku kodu.

   Przykład:

   ```python
   def func():
       y = 5  # Zmienna lokalna
       print(y)  # Możemy odwołać się do zmiennej lokalnej wewnątrz funkcji

   func()  # Wywołanie funkcji
   ```

3. **Zakres zagnieżdżony: <br>** Jeśli zdefiniujesz blok kodu wewnątrz innego bloku kodu, zakres zagnieżdżonego bloku jest dostępny wewnątrz tego bloku, ale nie na zewnątrz.

   Przykład:

   ```python
   def outer_func():
       x = 10  # Zmienna w zakresie zewnętrznym

       def inner_func():
           print(x)  # Możemy odwołać się do zmiennej z zakresu zewnętrznego

       inner_func()  # Wywołanie funkcji zagnieżdżonej

   outer_func()  # Wywołanie funkcji zewnętrznej
   ```

4. **Zmienne globalne i słowo kluczowe global: <br>** W przypadku zmiennych lokalnych i zagnieżdżonych, jeśli istnieje zmienna o tej samej nazwie w zakresie zewnętrznym, zakres wewnętrzny ma pierwszeństwo. Jednak jeśli chcesz modyfikować zmienną globalną wewnątrz funkcji, musisz użyć słowa kluczowego global.

   Przykład:

   ```python
   x = 10  # Zmienna globalna

   def func():
       global x  # Oznaczamy zmienną jako globalną
       x = 20  # Modyfikujemy zmienną globalną

   func()
   print(x)  # Wyświetli wartość 20
   ```

5. **Słowo kluczowe nonlocal: <br>**
   Nonlocal to słowo kluczowe używane wewnątrz funkcji w celu wskazania, że zmienna znajdująca się w zakresie zewnętrznym lokalnym ma być używana, a nie tworzona jako nowa zmienna w zakresie lokalnym bieżącej funkcji.

   Przykład:

   ```python
   def outer():
       x = 10  # Zmienna w zakresie zewnętrznym lokalnym

       def inner():
           nonlocal x  # Użyj zmiennej x z zewnętrznego zakresu lokalnego
           x += 5  # Zmiana wartości zmiennej x w zewnętrznym zakresie lokalnym
           print("Wartość zmiennej x wewnętrznej funkcji:", x)

       inner()
       print("Wartość zmiennej x w zewnętrznym zakresie lokalnym:", x)

   outer()

   # Wyjście:
   # Wartość zmiennej x wewnętrznej funkcji: 15
   # Wartość zmiennej x w zewnętrznym zakresie lokalnym: 15
   ```

   W tym przykładzie, używając słowa kluczowego "nonlocal", mamy dostęp do zmiennej "x" z zewnętrznego zakresu lokalnego w funkcji "inner()". Zmieniamy wartość tej zmiennej i widzimy, że wartość zmiennej "x" również się zmienia w zewnętrznym zakresie lokalnym funkcji "outer()".

   Słowo kluczowe "nonlocal" jest przydatne w przypadkach, gdy chcemy zmienić wartość zmiennej w zewnętrznym zakresie lokalnym z poziomu wewnętrznej funkcji.

# Klasy i obiekty OOP

1. **OOP - Programowanie obiektowe: <br>** Programowanie obiektowe (OOP) jest paradygmatem programowania, który opiera się na tworzeniu i manipulowaniu obiektami. Pozwala on na modelowanie rzeczywistości poprzez grupowanie danych i funkcji (metod) w logiczne jednostki.

2. **Klasa: <br>** Klasa jest szablonem lub wzorcem, który definiuje zachowanie i właściwości obiektów. Można ją traktować jako abstrakcyjny typ danych, który opisuje, jakie dane przechowuje oraz jakie operacje (metody) można na tych danych wykonać. Klasy są definiowane za pomocą słowa kluczowego class w większości języków programowania.

   Przykład:

   ```python
   class Pies:
       def __init__(self, imie: str, wiek: str):
           self.imie = imie
           self.wiek = wiek

       def szczekaj(self):
           print("Hau Hau!")

       def podaj_wiek(self):
           print(f"Wiek: {self.wiek}")

       def podaj_imie(self):
           print(f"Imie: {self.imie}")
   ```

3. **Obiekt: <br>** Obiekt to konkretne wystąpienie klasy. Jest instancją klasy, w której przechowywane są konkretne wartości dla właściwości. Może wywoływać metody zdefiniowane w klasie. Tworzenie obiektu nazywane jest inicjalizacją (instancjacją) klasy.

   Przykład:

   ```python
   pies1 = Pies("Burek", 3)
   pies2 = Pies("Azor", 5)

   pies: Pies = Pies("Burek", "5")
   pies.szczekaj()
   pies.podaj_imie()
   pies.podaj_wiek()

   pies1.szczekaj() # Wywołanie metody szczekaj na obiekcie pies1
   print(pies2.imie) # Wypisanie wartości właściwości imie obiektu pies2
   ```

4. **Gettery i Settery: <br>** - metody wykorzystywane w programowaniu obiektowym do dostępu i modyfikacji wartości prywatnych właściwości obiektu. Ich celem jest kontrola dostępu do danych i umożliwienie bardziej bezpośredniego zarządzania tymi danymi.

   **Getter:** to metoda, która umożliwia pobranie wartości prywatnej właściwości obiektu. Umożliwia dostęp tylko do odczytu i zazwyczaj zwraca wartość właściwości.

   Przykład:

   ```python
   class Osoba:
       def __init__(self, imie, nazwisko):
           self._imie = imie
           self._nazwisko = nazwisko

       def get_imie(self):
           return self._imie

       def get_nazwisko(self):
           return self._nazwisko

   osoba = Osoba("Jan", "Kowalski")
   print(osoba.get_imie())  # Wywołanie gettera get_imie()
   print(osoba.get_nazwisko())  # Wywołanie gettera get_nazwisko()
   ```

   W tym przykładzie, mamy klasę Osoba z prywatnymi właściwościami \_imie i \_nazwisko. Metody get_imie() i get_nazwisko() są getterami, które umożliwiają dostęp do odczytu wartości tych właściwości.

   **Setter:** to metoda, która umożliwia modyfikację wartości prywatnej właściwości obiektu. Umożliwia dostęp tylko do zapisu i zazwyczaj przyjmuje nową wartość jako argument.

   Przykład:

   ```python
   class Osoba:
       def __init__(self, imie, nazwisko):
           self._imie = imie
           self._nazwisko = nazwisko

       def set_imie(self, nowe_imie):
           self._imie = nowe_imie

       def set_nazwisko(self, nowe_nazwisko):
           self._nazwisko = nowe_nazwisko

   osoba = Osoba("Jan", "Kowalski")
   osoba.set_imie("Adam")  # Wywołanie settera set_imie()
   osoba.set_nazwisko("Nowak")  # Wywołanie settera set_nazwisko()
   print(osoba.get_imie())  # Wywołanie gettera get_imie() po zmianie imienia
   print(osoba.get_nazwisko())  # Wywołanie gettera get_nazwisko() po zmianie nazwiska
   ```

   W tym przykładzie, mamy klasę Osoba z prywatnymi właściwościami \_imie i \_nazwisko. Metody set_imie() i set_nazwisko() są setterami, które umożliwiają zmianę wartości tych właściwości.

# Prywatnosć w Pythonie

1. **Prywatnie strzeżone zmienne:**
   W Pythonie często stosuje się konwencję dodawania podkreślenia przed nazwą zmiennej, aby oznaczyć ją jako prywatną. Nie jest to jednak technicznie wymuszane przez interpreter.
   Przykład:

   ```python
   class PrzykladowaKlasa:
    def __init__(self):
        self._prywatna_zmienna = 10

    def _prywatna_metoda(self):
        print("To jest prywatna metoda")

   obiekt = PrzykladowaKlasa()
   print(obiekt._prywatna_zmienna)  # Mimo podkreślenia, zmienna jest dostępna spoza klasy
   obiekt._prywatna_metoda()  # Mimo podkreślenia, metoda jest dostępna spoza klasy
   ```

   Choć \_prywatna_zmienna i \_prywatna_metoda mają podkreślenie przed nazwą, nadal można uzyskać do nich dostęp spoza klasy. Jednak podkreślenie sygnalizuje programistom, że powinny być traktowane jako elementy prywatne i nie powinny być bezpośrednio modyfikowane spoza klasy.

2. **Globalne zmienne w klasach:**
   Wewnątrz klasy można definiować zmienne, które są dostępne dla wszystkich instancji tej klasy. Nazywane są one zmiennymi globalnymi w kontekście klasy.

   Przykład:

   ```python
   class PrzykladowaKlasa:
    globalna_zmienna = 10

    def __init__(self):
        self.lokalna_zmienna = 20

   obiekt1 = PrzykladowaKlasa()
   obiekt2 = PrzykladowaKlasa()

   print(obiekt1.globalna_zmienna)  # Dostęp do zmiennej globalnej z obiektu 1
   print(obiekt2.globalna_zmienna)  # Dostęp do zmiennej globalnej z obiektu 2

   obiekt1.globalna_zmienna = 15  # Modyfikacja zmiennej globalnej dla obiektu 1
   print(obiekt1.globalna_zmienna)  # Zmieniona wartość zmiennej globalnej dla obiektu 1
   print(obiekt2.globalna_zmienna)  # Wartość zmiennej globalnej dla obiektu 2 bez zmian
   ```

   W tym przykładzie globalna_zmienna jest zmienną globalną dla klasy PrzykladowaKlasa. Może być ona dostępna zarówno z poziomu samej klasy, jak i z poziomu każdej instancji tej klasy. Możemy ją odczytywać i modyfikować za pomocą obiektów utworzonych na podstawie klasy. Warto jednak zaznaczyć, że każda instancja ma swoją kopię zmiennej globalnej, a zmiany dokonane w jednym obiekcie nie wpływają na wartość tej zmiennej w innych obiektach.

# @property

1. @property jest dekoratorem w języku Python, który umożliwia definiowanie metod, które są używane jako właściwości obiektów. W praktyce pozwala na dostęp do metod jak do atrybutów (właściwości), co zapewnia większą elastyczność i kontrolę nad zachowaniem i dostępem do danych obiektu.

   ```python
   class Kolo:
       def __init__(self, promien):
           self._promien = promien

       @property
       def promien(self):
           return self._promien

       @promien.setter
       def promien(self, nowy_promien):
           if nowy_promien > 0:
               self._promien = nowy_promien
           else:
               raise ValueError("Promień musi być większy od zera.")

       @promien.deleter
       def promien(self):
           del self._promien

   # Tworzenie obiektu na podstawie klasy
   kolo = Kolo(5)

   # Użycie gettera
   print(kolo.promien) # Wyświetli: 5

   # Użycie settera
   kolo.promien = 7
   print(kolo.promien) # Wyświetli: 7

   # Próba ustawienia wartości ujemnej
   kolo.promien = -2 # Wygeneruje ValueError

   # Użycie deletera
   del kolo.promien
   print(kolo.promien) # Wygeneruje AttributeError: 'Kolo' object has no attribute '_promien'
   ```

   W powyższym przykładzie mamy klasę Kolo, która ma prywatne pole \_promien. Metoda promien() jest getterem i pozwala na odczyt wartości pola \_promien. Metoda promien() z dekoratorem @promien.setter działa jako setter i umożliwia zmianę wartości pola \_promien, pod warunkiem, że nowy promień jest większy od zera. Metoda promien() z dekoratorem @promien.deleter działa jako deleter i usuwa wartość pola \_promien.

2. Dzięki użyciu dekoratora @property możemy traktować metodę jako właściwość, co pozwala na bardziej elegancki i intuicyjny dostęp do danych obiektu.

   ```python
   class Person:
       def __init__(self, name):
           self._name = name

       @property
       def name(self):
           return self._name

       @name.setter
       def name(self, value):
           self._name = value

   # Tworzenie obiektu na podstawie klasy
   person = Person("Jan")

   # Odwoływanie się do gettera jak do atrybutu
   print(person.name)  # Wyświetli: Jan

   # Odwoływanie się do settera jak do atrybutu
   person.name = "Adam"

   # Ponowne odczytanie wartości atrybutu
   print(person.name)  # Wyświetli: Adam
   ```

   W powyższym przykładzie mamy klasę Person, która ma prywatne pole \_name. Metoda name() jest getterem i pozwala na odczyt wartości pola \_name. Metoda name() z dekoratorem @name.setter działa jako setter i umożliwia zmianę wartości pola \_name. Dzięki użyciu dekoratora @property możemy traktować metodę jako właściwość, co pozwala na bardziej elegancki i intuicyjny dostęp do danych obiektu.

3. Warto zauważyć, że w powyższym przykładzie nie ma metody name(), która pozwala na odczyt wartości pola \_name. Dzięki użyciu dekoratora @property możemy traktować metodę jako właściwość, co pozwala na bardziej elegancki i intuicyjny dostęp do danych obiektu.

   Przykład bez użycia dekoratora @property:

   ```python
   class Person:
       def __init__(self, name):
           self._name = name

       def get_name(self):
           return self._name

       def set_name(self, value):
           self._name = value

   # Tworzenie obiektu na podstawie klasy
   person = Person("Jan")

   # Użycie gettera
   print(person.get_name())  # Wyświetli: Jan

   # Użycie settera
   person.set_name("Adam")

   # Ponowne użycie gettera
   print(person.get_name())  # Wyświetli: Adam
   ```

# \_\_init\_\_ - konstruktor

W Pythonie konstruktor to specjalna metoda o nazwie **init**, która jest wywoływana automatycznie przy tworzeniu nowego obiektu klasy. Konstruktor służy do inicjalizacji atrybutów obiektu i może przyjmować argumenty.

Oto przykład definicji konstruktora w Pythonie:

```python
class Person:
   def __init__(self, name, age):
      self.name = name
      self.age = age
```

W powyższym przykładzie, klasa Person ma konstruktor \_\_init\_\_, który przyjmuje trzy argumenty: self, name i age. Argument self reprezentuje obiekt, który jest tworzony, a name i age są argumentami, które zostaną przekazane do konstruktora.

# \_\_str**() & \_\_repr**()

**\_\_str\_\_()** i **\_\_repr\_\_()** to specjalne metody w Pythonie, które pozwalają na zdefiniowanie reprezentacji tekstowej obiektu w czytelny sposób. Oto ich wyjaśnienie:

1. **\_\_str\_\_()**: Metoda **\_\_str\_\_()** służy do zdefiniowania czytelnej reprezentacji tekstowej obiektu. Jest wywoływana, gdy używasz funkcji **str()** na obiekcie lub gdy obiekt jest konwertowany na tekst za pomocą funkcji **print()**. Metoda **\_\_str\_\_()** zwraca ciąg znaków reprezentujący obiekt w sposób zrozumiały dla ludzi.

   Przykład użycia **\_\_str\_\_()**:

   ```python
   class Person:
       def __init__(self, name, age):
           self.name = name
           self.age = age

       def __str__(self):
           return f"Person: {self.name}, {self.age} years old"

   person = Person("Jan", 25)
   print(person)  # Wyświetli: Person: Jan, 25 years old
   print(person.__str__())  # Wyświetli: Person: Jan, 25 years old
   ```

   W powyższym przykładzie, metoda **\_\_str\_\_()** jest zdefiniowana w klasie Person. Zwraca ona reprezentację tekstową obiektu Person w formacie "Person: <name>, <age> years old". Gdy używamy **str(person)** lub **print(person)**, metoda **\_\_str\_\_()** jest automatycznie wywoływana, a zwrócony ciąg znaków jest wyświetlany.

2. **\_\_repr\_\_()**: Metoda **\_\_repr\_\_()** służy do zdefiniowania reprezentacji tekstowej obiektu, która powinna być używana dla celów reprezentacji obiektu wewnątrz kodu Pythona. Jest wywoływana, gdy używasz funkcji **repr()** na obiekcie. Metoda **\_\_repr\_\_()** zwraca ciąg znaków, który powinien zawierać wystarczające informacje, aby móc odtworzyć obiekt.

   Przykład użycia **\_\_repr\_\_()**:

   ```python
   class Point:
       def __init__(self, x, y):
           self.x = x
           self.y = y

       def __repr__(self):
           return f"Point({self.x}, {self.y})"

   point = Point(3, 5)
   print(repr(point))  # Wyświetli: Point(3, 5)
   print(point)  # Wyświetli: Point(3, 5)
   print(point.__repr__())  # Wyświetli: Point(3, 5)
   # Reprezentacja bardziej dla programisty to samo co
   # Point(x=3, y=5)
   ```

   W powyższym przykładzie, metoda **\_\_repr\_\_()** jest zdefiniowana w klasie Point. Zwraca ona reprezentację tekstową obiektu Point w formacie "Point(<x>, <y>)". Gdy używamy **repr(point)**, metoda **\_\_repr\_\_()** jest automatycznie wywoływana, a zwrócony ciąg znaków jest wyświetlany.

Podsumowując **\_\_str\_\_()** służy do reprezentacji tekstowej obiektu dla użytkownika, natomiast **\_\_repr\_\_()** służy do reprezentacji obiektu wewnątrz kodu Pythona, aby można było go odtworzyć. Oba metody są przydatne w celu dostarczenia czytelnych i użytecznych reprezentacji obiektów w zależności od kontekstu użycia.

# \_\_eq\_\_()

Metoda **\_\_eq\_\_()** jest specjalną metodą w Pythonie, która służy do definiowania operacji porównywania równości obiektów. Jest wywoływana, gdy używasz operatora **==** do porównania dwóch obiektów.

```python
class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def __eq__(self, other):
        if isinstance(other, Point):
            return self.x == other.x and self.y == other.y
        return False

   point1 = Point(3, 5)
   point2 = Point(3, 5)
   point3 = Point(2, 4)

   print(point1 == point2)  # True
   print(point1 == point3)  # False
```

# Private & Protected

W Pythonie konwencja mówi, że atrybuty i metody, których nazwy zaczynają się od pojedynczego podkreślenia **\_**, są oznaczone jako "protected", a te, których nazwy zaczynają się od dwóch podkreśleń **\_\_**, są oznaczone jako "private". Oto wyjaśnienie tych pojęć:

1. **Protected:**
   Atrybuty lub metody oznaczone jako "protected" są dostępne tylko w obrębie danej klasy oraz jej podklas.
   Choć dostęp do tych atrybutów lub metod jest możliwy spoza klasy, programiści powinni traktować je jako elementy wewnętrzne klasy, które nie powinny być bezpośrednio modyfikowane lub używane spoza niej.
   Oznaczenie atrybutu lub metody jako "protected" jest bardziej konwencją niż ścisłą kontrolą dostępu, ponieważ Python nie narzuca ograniczeń w tym zakresie.

   ```python
   class MyClass:
      def __init__(self):
         self._protected_attr = 42

      def _protected_method(self):
         print("To jest chroniona metoda")

   obj = MyClass()
   print(obj._protected_attr)  # Wyświetli: 42
   obj._protected_method()  # Wyświetli: To jest chroniona metoda
   ```

   W powyższym przykładzie _protected_attr i \_protected_method są oznaczone jako "protected" za pomocą pojedynczego podkreślenia _. Choć można uzyskać dostęp do tych elementów spoza klasy, programiści powinni traktować je jako wewnętrzne elementy klasy, które nie powinny być używane bezpośrednio przez inne części programu.

2. **Private:**
   Private ozancza, że atrybuty lub metody są dostępne tylko w obrębie danej klasy i nie są dostępne spoza niej.

   Oznaczenie atrybutu lub metody jako "private" zapewnia większą prywatność i sugeruje, że nie powinny być bezpośrednio modyfikowane lub używane spoza klasy.

   Python wprowadza pewną modyfikację w nazwach atrybutów lub metod oznaczonych jako "private" poprzez dodanie przed nimi nazwy klasy. Nazywa się to "name mangling".

   ```python
   class MyClass:
       def __init__(self):
           self.__private_attr = 42

       def __private_method(self):
           print("To jest prywatna metoda")

   obj = MyClass()

   print(obj.__private_attr)  # Wygeneruje błąd: 'MyClass' object has no attribute '__private_attr'

   obj.__private_method()  # Wygeneruje błąd: 'MyClass' object has no attribute '__private_method'
   ```

   W powyższym przykładzie \_\_private_attr i \_\_private_method są oznaczone jako "private" za pomocą dwóch podkreśleń \_\_. Te elementy nie są dostępne spoza klasy i próba uzyskania do nich dostępu generuje błąd.

   Warto jednak zauważyć, że w przypadku atrybutów oznaczonych jako "private" w Pythonie stosuje się mechanizm "name mangling", w którym przed nazwą atrybutu dodawana jest nazwa klasy. Można uzyskać dostęp do tych atrybutów poprzez zmienienie ich nazw.

   ```python
   class MyClass:
       def __init__(self):
           self.__private_attr = 42

   obj = MyClass()
   print(obj._MyClass__private_attr)  # Wyświetli: 42
   ```

   Choć można uzyskać dostęp do atrybutu \_\_private_attr poprzez taką zmienioną nazwę, należy pamiętać, że takie zachowanie jest niezalecane, a atrybuty oznaczone jako "private" powinny być traktowane jako prywatne i niedostępne spoza klasy.

# Dziedziczenie (inheritance)

Dziedziczenie (inheritance) to mechanizm w programowaniu obiektowym, który umożliwia tworzenie nowych klas na podstawie istniejących klas. Klasa, która dziedziczy (nazywana podklasą lub klasą pochodną), może odziedziczyć atrybuty i metody z klasy, z której dziedziczy (nazywanej klasą bazową, nadklasą lub klasą nadrzędną).

Główne zalety dziedziczenia to:

- Reużywalność kodu: Dziedziczenie pozwala na ponowne wykorzystanie już istniejącego kodu z klasy bazowej, co prowadzi do bardziej efektywnego i zwięzłego programowania.

- Hierarchia klas: Dziedziczenie pozwala na tworzenie hierarchii klas, gdzie klasy pochodne mogą rozszerzać funkcjonalność klasy bazowej, dodając nowe atrybuty i metody lub nadpisując istniejące.

- Polimorfizm: Dziedziczenie umożliwia stosowanie polimorfizmu, czyli tworzenia wielu obiektów różnych klas, które mogą być traktowane w sposób jednolity w kontekście klasy bazowej. To pozwala na bardziej elastyczne i generyczne programowanie.

Przykład:

```python
class Animal:
    def __init__(self, name):
        self.name = name

    def speak(self):
        print("Zwierzę mówi: ")

class Dog(Animal):
      def speak(self):
         print("Hau Hau!")

class Cat(Animal):
      def speak(self):
         print("Miau Miau!")

```

# Super()

Funkcja super() w Pythonie jest używana do odwoływania się do metody lub atrybutu z klasy nadrzędnej (klasy bazowej) w przypadku dziedziczenia. Umożliwia ona dostęp do funkcjonalności zdefiniowanej w klasie nadrzędnej, co jest przydatne, gdy chcemy rozszerzyć lub zmodyfikować zachowanie tej funkcjonalności w klasie pochodnej.

Główne zastosowania super() to:

1. Wywoływanie metody z klasy nadrzędnej: super() pozwala na wywołanie metody z klasy nadrzędnej, co jest szczególnie przydatne, gdy klasa pochodna chce rozszerzyć funkcjonalność metody z klasy bazowej, a jednocześnie zachować jej podstawowe działanie. Wywołanie super().metoda() wykonuje metodę metoda() z klasy nadrzędnej.

   ```python
      class BaseClass:
         def metoda(self):
            print("Metoda z klasy bazowej")

      class DerivedClass(BaseClass):
         def metoda(self):
            super().metoda()  # Wywołanie metody z klasy bazowej
            print("Metoda z klasy pochodnej")

      obj = DerivedClass()
      obj.metoda()
      # Wyświetli:
      # Metoda z klasy bazowej
      # Metoda z klasy pochodnej
   ```

2. Przekazywanie argumentów do klasy nadrzędnej: super() może być również używane do przekazywania argumentów do konstruktora klasy nadrzędnej. Umożliwia to inicjalizację atrybutów z klasy bazowej przed dodaniem nowych atrybutów z klasy pochodnej.

   ```python
      class BaseClass:
         def __init__(self, x):
            self.x = x

      class DerivedClass(BaseClass):
         def __init__(self, x, y):
            super().__init__(x)  # Inicjalizacja atrybutu z klasy bazowej
            self.y = y

      obj = DerivedClass(10, 20)
      print(obj.x)  # Wyświetli: 10
      print(obj.y)  # Wyświetli: 20
   ```

   Użycie super() jest szczególnie przydatne, gdy mamy do czynienia z wielopoziomowym dziedziczeniem, gdzie jedna klasa dziedziczy po innej, a ta z kolei po kolejnej. Pozwala to na wygodne odwoływanie się do funkcjonalności z klas nadrzędnych i utrzymywanie hierarchii dziedziczenia.

# Dekoratory w Pythonie

Dekoratory w Pythonie to funkcje, które przyjmują inną funkcję jako argument, wykonują pewne działania i zwracają funkcję. Dekoratory są używane do modyfikowania funkcji bez zmiany ich kodu. Dekoratory są bardzo przydatne w przypadku, gdy chcemy dodać funkcjonalność do istniejącej funkcji.

W języku Python mamy dwa dekoratory funkcyjne, które można stosować w klasach: @classmethod i @staticmethod. Oba dekoratory służą do definiowania metod, ale różnią się w sposobie, w jaki odnoszą się do klasy i obiektów.

1. @classmethod:
   Metody oznaczone dekoratorem @classmethod są powiązane z klasą, a nie z instancją obiektu.
   Metoda przyjmuje pierwszy parametr, który jest obiektem reprezentującym klasę, zwykle oznaczanym przez konwencję jako cls.
   Metody klasowe mogą uzyskiwać dostęp do atrybutów klasy, a nie atrybutów instancji.
   Metoda klasowa jest dostępna zarówno dla samej klasy, jak i dla jej instancji.
   Często używane do tworzenia alternatywnych konstruktorów lub metod dostępowych do atrybutów klasy.

   ```python
      class MyClass:
         class_attr = 42

         @classmethod
         def class_method(cls):
            print("To jest metoda klasowa")
            print("Wartość class_attr:", cls.class_attr)

      MyClass.class_method()  # Wywołanie metody klasowej na samej klasie
      # Wyświetli:
      # To jest metoda klasowa
      # Wartość class_attr: 42

      obj = MyClass()
      obj.class_method()  # Wywołanie metody klasowej na instancji
      # Wyświetli:
      # To jest metoda klasowa
      # Wartość class_attr: 42
   ```

   W powyższym przykładzie class_method jest oznaczona jako metoda klasowa za pomocą dekoratora @classmethod. Metoda ta może uzyskiwać dostęp do atrybutu klasy class_attr poprzez parametr cls reprezentujący klasę.

2. @staticmethod:
   Metody oznaczone dekoratorem @staticmethod nie są powiązane ani z klasą, ani z instancją obiektu.
   Metoda nie przyjmuje specjalnego parametru reprezentującego klasę lub instancję.
   Metoda statyczna nie ma dostępu ani do atrybutów klasy, ani do atrybutów instancji.
   Jest dostępna zarówno dla samej klasy, jak i dla jej instancji.

   Często używane do definiowania funkcjonalności, która nie wymaga dostępu do atrybutów klasy ani instancji.

   ```python
      class MyClass:
         @staticmethod
         def static_method():
            print("To jest metoda statyczna")

      MyClass.static_method()  # Wywołanie metody statycznej na samej klasie

      # Wyświetli: To jest metoda statyczna

      obj = MyClass()
      obj.static_method()  # Wywołanie metody statycznej na instancji

      # Wyświetli: To jest metoda statyczna
   ```

   W powyższym przykładzie static_method jest oznaczona jako metoda statyczna za pomocą dekoratora @staticmethod. Metoda ta nie przyjmuje żadnych dodatkowych parametrów i nie ma dostępu do atrybutów klasy ani instancji.

3. @abstractmethod
   Dekorator @abstractmethod jest używany w języku Python w kontekście tworzenia klas abstrakcyjnych i metod abstrakcyjnych. Klasa abstrakcyjna to klasa, która nie może być bezpośrednio instancjonowana, a metoda abstrakcyjna to metoda, która musi być zaimplementowana w klasach pochodnych. Dekorator @abstractmethod jest używany do oznaczenia metod abstrakcyjnych.

   Metoda oznaczona dekoratorem @abstractmethod nie posiada implementacji w klasie abstrakcyjnej.
   Klasa abstrakcyjna może zawierać zarówno metody abstrakcyjne, jak i metody z implementacją.
   Klasy dziedziczące po klasie abstrakcyjnej muszą zaimplementować wszystkie metody abstrakcyjne.
   Jeśli klasa dziedzicząca nie implementuje wszystkich metod abstrakcyjnych, to również staje się klasą abstrakcyjną i nie można jej bezpośrednio instancjonować.
   Przykład:

   ```python
      from abc import ABC, abstractmethod

      class AbstractClass(ABC):
         @abstractmethod
         def abstract_method(self):
            pass

         def concrete_method(self):
            print("Metoda konkretna")

      class ConcreteClass(AbstractClass):
         def abstract_method(self):
            print("Implementacja metody abstrakcyjnej")

      # Obiekt klasy abstrakcyjnej nie może być bezpośrednio utworzony
      # abstract_obj = AbstractClass()  # Wygeneruje TypeError

      concrete_obj = ConcreteClass()
      concrete_obj.abstract_method()  # Wywołanie zaimplementowanej metody abstrakcyjnej
      # Wyświetli: Implementacja metody abstrakcyjnej

      concrete_obj.concrete_method()  # Wywołanie metody konkretnej
      # Wyświetli: Metoda konkretna
   ```

   W powyższym przykładzie mamy klasę abstrakcyjną AbstractClass, która zawiera jedną metodę abstrakcyjną abstract_method oznaczoną dekoratorem @abstractmethod. Klasa ta zawiera również metodę konkretną concrete_method z implementacją. Klasa ConcreteClass dziedziczy po klasie abstrakcyjnej i implementuje metodę abstrakcyjną abstract_method.

   Ważne jest zauważenie, że próba utworzenia obiektu klasy abstrakcyjnej AbstractClass spowoduje błąd TypeError, ponieważ klasa abstrakcyjna nie może być bezpośrednio instancjonowana. Jednak możemy utworzyć obiekt klasy ConcreteClass, która implementuje wszystkie wymagane metody abstrakcyjne i dziedziczy metody konkretne.

# \_\_new\_\_ i \_\_init\_\_:

1. W języku Python, \_\_init** i \_\_new** są dwoma specjalnymi metodami, które są wywoływane podczas tworzenia nowego obiektu. Oto różnice między nimi:

2. \_\_new\_\_:

   - \_\_new** jest statyczną metodą, która jest wywoływana przed \_\_init**.
   - Jest odpowiedzialna za tworzenie i zwracanie nowego obiektu.
   - Przyjmuje jako argument klasę, dla której jest wywoływana (cls).
   - Może być używana do modyfikacji procesu tworzenia obiektu lub nawet do zwrócenia innego obiektu niż ten, który był pierwotnie tworzony.
   - Jest rzadziej używana niż \_\_init\_\_ i najczęściej jest wykorzystywana w przypadkach zaawansowanych, takich jak tworzenie obiektów niemutowalnych.

3. \_\_init\_\_:

   - \_\_init** jest metodą inicjalizacyjną, która jest wywoływana po \_\_new**.
   - Jest używana do inicjalizacji nowo utworzonego obiektu.
   - Przyjmuje jako argument nowo utworzony obiekt (self) oraz inne argumenty, które mogą być przekazane podczas tworzenia obiektu.
   - Metoda \_\_init\_\_ jest odpowiedzialna za ustawianie początkowych wartości atrybutów obiektu i wykonuje inne operacje inicjalizacyjne.
   - Jest powszechnie używana do konfiguracji obiektu i przygotowania go do dalszego użycia.

4. Przykład ilustrujący różnicę między \_\_new** a \_\_init**:

   ```python
   class MyClass:
       def __new__(cls):
           print("Metoda __new__ została wywołana")
           instance = super().__new__(cls)
           return instance

       def __init__(self):
           print("Metoda __init__ została wywołana")

   obj = MyClass()
   # Wyświetli:
   # Metoda __new__ została wywołana
   # Metoda __init__ została wywołana
   ```

   W tym przykładzie \_\_new** jest wywoływana jako pierwsza i jest odpowiedzialna za tworzenie nowego obiektu MyClass. Następnie \_\_init** jest wywoływana jako druga i inicjalizuje ten nowo utworzony obiekt. W rezultacie widzimy, że najpierw jest wyświetlana informacja z \_\_new**, a następnie z \_\_init**.

5. Przykład: Dostosowanie tworzenia obiektu w klasie dziedziczącej:

   ```python
   class Singleton:
       _instance = None

       def __new__(cls):
           if cls._instance is None:
               cls._instance = super().__new__(cls)
           return cls._instance

       def __init__(self):
           print("Tworzenie obiektu Singleton")


   obj1 = Singleton()  # Tworzenie obiektu Singleton
   obj2 = Singleton()  # Istniejący obiekt Singleton
   ```

   W tym przykładzie klasa Singleton wykorzystuje metodę \_\_new** do zapewnienia, że zawsze tworzony jest tylko jeden obiekt tej klasy. Jeśli instancja \_instance nie istnieje, tworzony jest nowy obiekt i przypisywany do \_instance. W przeciwnym razie zwracany jest istniejący obiekt. Metoda \_\_init** jest wywoływana tylko przy tworzeniu pierwszej instancji.

6. Przykład: Inicjalizacja atrybutów na podstawie argumentów:

   ```python
   class Person:
       def __new__(cls, name):
           instance = super().__new__(cls)
           return instance

       def __init__(self, name):
           self.name = name


   person = Person("Jan")
   print(person.name)  # Wyświetli: Jan
   ```

   W tym przykładzie klasa Person wykorzystuje metodę \_\_new** do utworzenia nowego obiektu, a metoda \_\_init** jest wywoływana, aby zainicjalizować atrybut name na podstawie przekazanego argumentu. Dzięki temu możliwe jest ustawienie początkowych wartości atrybutów obiektu podczas tworzenia.

7. Przykład: Tworzenie niemutowalnych obiektów:

   ```python
   class ImmutableClass:
       def __new__(cls, value):
           if isinstance(value, int):
               instance = super().__new__(cls)
               instance._value = value
               return instance
           else:
               raise ValueError("Invalid value type")

       def __init__(self, value):
           pass

       def get_value(self):
           return self._value


   obj = ImmutableClass(10)
   print(obj.get_value())  # Wyświetli: 10
   ```

   W tym przykładzie klasa ImmutableClass wykorzystuje metodę \_\_new\_\_ do tworzenia niemutowalnych obiektów. Metoda ta sprawdza, czy wartość przekazana do konstruktora jest typu int. Jeśli tak, tworzony jest nowy obiekt i wartość jest przypisywana do atrybutu \_value. Dzięki temu tworzone obiekty są niemutowalne, a wartość nie może być zmieniana po utworzeniu obiektu.

8. Praktyczne wykorzystanie \_\_new\_\_ i \_\_init\_\_:

   - \_\_new\_\_ i \_\_init\_\_ są rzadko używane w typowych programach Pythona. Są one jednak bardzo przydatne w zaawansowanych przypadkach, takich jak tworzenie niemutowalnych obiektów, tworzenie obiektów niestandardowych lub dostosowywanie tworzenia obiektów w klasach dziedziczących.

   ```python
   class Connection:
      _instance = None
      _is_connected = False

      def __new__(cls):
         if cls._instance is None:
            cls._instance = super().__new__(cls)
         return cls._instance

      def connect(self):
         if self._is_connected:
            print("Połączenie jest już aktywne.")
         else:
            self._is_connected = True
            print("Połączenie zostało nawiązane.")

      def disconnect(self):
         if self._is_connected:
            self._is_connected = False
            print("Połączenie zostało zamknięte.")
         else:
            print("Brak aktywnego połączenia.")


   # Tworzenie instancji klasy Connection
   connection1 = Connection()
   connection1.connect()  # Połączenie zostało nawiązane.

   # Próba utworzenia kolejnej instancji klasy Connection
   connection2 = Connection()
   connection2.connect()  # Połączenie jest już aktywne.

   # Zamykanie połączenia
   connection1.disconnect()  # Połączenie zostało zamknięte.
   connection2.disconnect()  # Brak aktywnego połączenia.
   ```

# Wbudowane funkcje

https://docs.python.org/3/library/functions.html

https://www.programiz.com/python-programming/methods/built-in/abs

# A

1. **abs()** - zwraca wartość bezwzględną liczby
   abs(x) - zwraca wartość bezwzględną liczby x

   ```python
   print(abs(-10))  # Wynik: 10
   print(abs(5.5))  # Wynik: 5.5
   ```

2. **aiter()** - zwraca asynchroniczny iterator dla obiektu

   ```python
   async def my_coroutine():
       my_list = [1, 2, 3, 4, 5]
       async for item in aiter(my_list):
           print(item)

   asyncio.run(my_coroutine())
   ```

3. **all()** - zwraca True, jeśli wszystkie elementy w iterowalnym obiekcie iterable są prawdziwe (konwertowane na bool), w przeciwnym razie zwraca False.

   ```python
   my_list = [True, True, False]
   print(all(my_list))  # Wynik: False
   ```

4. **any()** - zwraca True, jeśli przynajmniej jeden element w iterowalnym obiekcie iterable jest prawdziwy (konwertowany na bool), w przeciwnym razie zwraca False.

   ```python
   my_list = [False, False, True]
   print(any(my_list))  # Wynik: True
   ```

5. **anext()** - zwraca następny element z iteratora iterator. Jeśli iterator jest wyczerpany, zwraca wartość default (jeśli podana) lub podnosi wyjątek StopIteration.

   ```python
   my_iterator = iter([1, 2, 3])
   print(anext(my_iterator, None))  # Wynik: 1
   print(anext(my_iterator, None))  # Wynik: 2
   print(anext(my_iterator, 'Koniec'))  # Wynik: 3
   print(anext(my_iterator, 'Koniec'))  # Wynik: 'Koniec'
   ```

6. **ascii()** - zwraca reprezentację obiektu obj jako ciąg znaków w notacji ASCII.
   ```python
   print(ascii('łódź'))  # Wynik: '\\u0142\\xf3d\\u017a'
   print(ascii(10))  # Wynik: '10'
   print(ascii(['a', 'b', 'c']))  # Wynik: "['a', 'b', 'c']"
   ```

# B

1. **bin()** - zwraca reprezentację liczby całkowitej x jako ciąg znaków w formacie dwójkowym.

   ```python
   print(bin(10))  # Wynik: '0b1010'
   ```

2. **bool()** - konwertuje wartość x na typ logiczny (True lub False).

   ```python
   print(bool(0))  # Wynik: False
   print(bool(1))  # Wynik: True
   print(bool([]))  # Wynik: False
   print(bool([1, 2, 3]))  # Wynik: True
   ```

3. **breakpoint()** - wywołuje punkt przerwania w kodzie, umożliwiając debugowanie. Jest dostępny w Pythonie 3.7 i nowszych wersjach.

   ```python
   x = 10
   breakpoint()
   print(x)  # Kod zostanie zatrzymany w punkcie przerwania, umożliwiając inspekcję wartości zmiennych
   ```

4. **bytearray()** - zwraca nowy obiekt bytearray, który jest modyfikowalnym ciągiem bajtów. Może być tworzony na podstawie innych obiektów bajtowych, ciągów znaków lub list liczb całkowitych z zakresu 0-255.

   ```python
   my_bytes = bytearray(b'hello')
   print(my_bytes)  # Wynik: bytearray(b'hello')
   my_bytes[0] = 104  # Modyfikacja bajtu
   print(my_bytes)  # Wynik: bytearray(b'hhllo')
   ```

5. **bytes()** - zwraca nowy obiekt bytes, który jest niemodyfikowalnym ciągiem bajtów. Może być tworzony na podstawie innych obiektów bajtowych, ciągów znaków lub list liczb całkowitych z zakresu 0-255.

   ```python
   my_bytes = bytes(b'hello')
   print(my_bytes)  # Wynik: b'hello'
   # my_bytes[0] = 104  # Błąd! Obiekt bytes jest niemodyfikowalny
   ```

# C

1. **callable()** - sprawdza, czy dany obiekt jest wywoływalny, czyli czy można go użyć jak funkcję. Zwraca wartość True, jeśli obiekt jest wywoływalny, a False w przeciwnym przypadku.

   ```python
   def my_function():
       print("Hello, World!")

   print(callable(my_function))  # True

   x = 5
   print(callable(x))  # False
   ```

2. **chr()** - zwraca znak reprezentowany przez podany kod Unicode. Przyjmuje jako argument liczbę całkowitą, która jest kodem Unicode i zwraca odpowiadający jej znak.

   ```python
   print(chr(65))  # 'A'
   print(chr(8364))  # '€'
   ```

3. **classmethod()** - służy do utworzenia metody klasy w Pythonie. Metody klasy są powiązane z klasą, a nie z instancjami klasy. Deklarując metodę jako classmethod, możemy ją wywoływać zarówno na poziomie klasy, jak i na poziomie instancji.

   ```python
   class MyClass:
       @classmethod
       def my_method(cls):
           print("This is a class method.")

   MyClass.my_method()  # This is a class method.

   obj = MyClass()
   obj.my_method()  # This is a class method.
   ```

4. **compile()** - służy do kompilacji kodu źródłowego Pythona. Przyjmuje jako argument kod źródłowy Pythona i zwraca obiekt kodu skompilowanego, który można później wykonać lub ewaluować.

   ```python
   source_code = """
   def multiply(a, b):
      return a * b

   print(multiply(5, 3))
   """

   compiled_code = compile(source_code, "<string>", "exec")
   exec(compiled_code)
   ```

5. **complex()** - służy do tworzenia liczby zespolonej w Pythonie. Przyjmuje dwa argumenty, część rzeczywistą i część urojoną, które mogą być liczbami lub wyrażeniami liczbowymi.

   ```python
   z1 = complex(2, 3)
   print(z1)  # (2+3j)

   z2 = complex(4.5, -2.1)
   print(z2)  # (4.5-2.1j)
   ```

# D

1. **delattr()** - służy do usuwania atrybutu z obiektu. Przyjmuje dwa argumenty: obiekt i nazwę atrybutu, który ma zostać usunięty.

   ```python
   class MyClass:
       x = 5

   obj = MyClass()
   print(obj.x)  # 5

   delattr(obj, "x")
   print(obj.x)  # AttributeError: 'MyClass' object has no attribute 'x'
   ```

2. **dict()** - służy do tworzenia słownika w Pythonie. Słownik jest typem danych w Pythonie, który przechowuje pary klucz-wartość. Funkcja dict() może przyjąć różne formy argumentów, takie jak iterowalne obiekty, sekwencje par klucz-wartość lub argumenty nazwane.

   ```python
   # Tworzenie słownika za pomocą argumentów nazwanych
   my_dict = dict(name="John", age=30, city="New York")
   print(my_dict)  # {'name': 'John', 'age': 30, 'city': 'New York'}

   # Tworzenie słownika z listy par klucz-wartość
   pairs = [("a", 1), ("b", 2), ("c", 3)]
   my_dict = dict(pairs)
   print(my_dict)  # {'a': 1, 'b': 2, 'c': 3}
   ```

3. **dir()** - służy do wyświetlania listy nazw atrybutów i metod danego obiektu. Może być wywołana bez argumentu lub z argumentem, który jest obiektem.

   ```python
   my_list = [1, 2, 3]
   print(dir(my_list))

   my_string = "Hello, World!"
   print(dir(my_string))
   ```

4. **divmod()** - służy do wykonywania dzielenia całkowitoliczbowego dwóch liczb i zwracania wyniku oraz reszty z tego dzielenia. Przyjmuje dwa argumenty: liczbę dzielona i dzielnik.

   ```python
   result = divmod(10, 3)
   print(result)  # (3, 1)

   quotient, remainder = divmod(20, 7)
   print(quotient)  # 2
   print(remainder)  # 6
   ```

# E

1. **enumerate()** - służy do wyliczania elementów iterowalnych, takich jak lista, krotka, słownik, itp. Zwraca obiekt wyliczeniowy, który składa się z indeksu i wartości każdego elementu w iterowalnym obiekcie.

   ```python
   my_list = ['apple', 'banana', 'orange']

   for index, value in enumerate(my_list):
      print(index, value)

   # 0 apple
   # 1 banana
   # 2 orange
   ```

2. **eval()** - służy do wykonywania kodu Pythona, który jest przekazany jako ciąg znaków. Przyjmuje jeden argument, który jest ciągiem znaków.

   ```python
   x = 5
   result = eval('x + 10')
   print(result)  # 15

   expression = input("Podaj wyrażenie matematyczne: ")
   result = eval(expression)
   print(result)
   ```

3. **exec()** - służy do wykonywania kodu Pythona, który jest przekazany jako ciąg znaków. Przyjmuje jeden argument, który jest ciągiem znaków.

   ```python
   code = """
   x = 5
   y = 10
   print(x + y)
   """

   exec(code)

   ```

# F

1. **filter()** - służy do filtrowania elementów iterowalnych, takich jak lista, krotka, słownik, itp. Przyjmuje dwa argumenty: funkcję i iterowalny obiekt. Zwraca obiekt filtrujący, który składa się z tych elementów iterowalnych, dla których funkcja zwraca True.

   ```python
   def is_even(num):
      return num % 2 == 0

   my_list = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
   result = filter(is_even, my_list)
   print(list(result))  # [2, 4, 6, 8, 10]
   ```

2. **float()** - służy do konwersji obiektów na typ float. Przyjmuje jeden argument, który jest obiektem, który ma zostać przekonwertowany na typ float.

   ```python
   print(float(10))  # 10.0
   print(float(10.5))  # 10.5
   print(float("10"))  # 10.0
   print(float("10.5"))  # 10.5
   ```

3. **format()** - służy do formatowania wartości i wstawiania ich do łańcucha znaków. Może być używana wraz z oznacznikami formatu, takimi jak {}, do dynamicznego wstawiania wartości.

   ```python
   name = "John"
   age = 30
   print("My name is {} and I'm {} years old.".format(name, age))
   # My name is John and I'm 30 years old.

   -> teraz lepiej używać f-stringów
   ```

# G

1. **getattr()** - służy do pobierania wartości atrybutu obiektu na podstawie jego nazwy. Przyjmuje dwa argumenty: obiekt i nazwę atrybutu. Jeśli atrybut istnieje, funkcja zwraca jego wartość. W przeciwnym razie można podać wartość domyślną, która zostanie zwrócona.

   ```python
   class Person:
      name = "John"
      age = 30

   person = Person()
   name = getattr(person, "name")
   print(name)  # "John"

   profession = getattr(person, "profession", "Unknown")
   print(profession)  # "Unknown"
   ```

2. **globals()** - zwraca słownik reprezentujący globalne przestrzenie nazw. Słownik ten zawiera zmienne globalne dostępne w bieżącym zakresie. Można użyć funkcji globals() do odczytu wartości lub modyfikacji globalnych zmiennych.

   ```python
   x = 5
   y = 10

   global_vars = globals()
   print(global_vars["x"])  # 5

   global_vars["y"] = 20
   print(y)  # 20
   ```

# H

1. **hasattr()** - służy do sprawdzania, czy dany obiekt posiada określony atrybut. Przyjmuje dwa argumenty: obiekt i nazwę atrybutu. Zwraca wartość True, jeśli atrybut istnieje, lub False w przeciwnym przypadku.

   ```python
   class Person:
      name = "John"
      age = 30

   person = Person()
   print(hasattr(person, "name"))  # True
   print(hasattr(person, "profession"))  # False
   ```

2. **hash()** - służy do obliczania hasha (wartości skrótu) dla danego obiektu. Hash jest liczbą całkowitą, która jest używana do efektywnego identyfikowania obiektów w kolekcjach takich jak słowniki lub zbioru.

   ```python
   print(hash("Hello"))  # 3064033309058722556

   my_set = {"apple", "banana", "orange"}
   print(hash(my_set))  # TypeError: unhashable type: 'set'
   ```

3. **help()** - wyświetla pomoc dla danego obiektu lub tematu. Może być używana do uzyskiwania informacji na temat wbudowanych modułów, funkcji, klas itp.

   ```python
   help(list)
   help(dict)
   ```

4. **hex()** - służy do konwertowania liczby całkowitej na łańcuch znaków reprezentujący jej szesnastkową postać. Zwraca prefiks "0x" przed wartością szesnastkową.

   ```python
   x = 255
   hex_value = hex(x)
   print(hex_value)  # "0xff"
   ```

# I

1. **id()** - służy do zwracania unikalnego identyfikatora obiektu. Ten identyfikator jest liczbą całkowitą, która jest przypisana do danego obiektu podczas jego utworzenia i nie zmienia się w trakcie życia obiektu.

   ```python
   x = 10
   print(id(x))  # Unikalny identyfikator obiektu x

   y = x
   print(id(y))  # Unikalny identyfikator obiektu y (taki sam jak x)
   ```

2. **input()** - służy do pobierania danych od użytkownika z konsoli. Wyświetla wiadomość podaną jako argument i czeka na wprowadzenie danych przez użytkownika.

   ```python
   name = input("Podaj swoje imię: ")
   print("Witaj, " + name + "!")
   ```

3. **int()** - służy do konwersji wartości na liczbę całkowitą (integer). Może być używana do konwersji zmiennych liczbowych, łańcuchów znaków lub innych typów danych na liczbę całkowitą.

   ```python
   x = int(3.14)
   print(x)  # 3

   y = int("10")
   print(y)  # 10
   ```

4. **isinstance()** - służy do sprawdzania, czy dany obiekt jest instancją określonego typu. Przyjmuje dwa argumenty: obiekt i typ, który chcemy sprawdzić. Zwraca wartość True, jeśli obiekt jest instancją tego typu, lub False w przeciwnym przypadku.

   ```python
   x = 5
   print(isinstance(x, int))  # True

   y = "Hello"
   print(isinstance(y, int))  # False
   ```

5. **issubclass()** - służy do sprawdzania, czy dany typ jest podklasą określonego innego typu. Przyjmuje dwa argumenty: typ potencjalnej podklasy i typ, którego podklasę chcemy sprawdzić. Zwraca wartość True, jeśli dany typ jest podklasą, lub False w przeciwnym przypadku.

   ```python
   class A:
       pass

   class B(A):
       pass

   print(issubclass(B, A))  # True
   print(issubclass(A, B))  # False
   ```

6. **iter()** - służy do tworzenia iteratora dla danego obiektu. Iterator umożliwia iterację po elementach obiektu za pomocą pętli for lub funkcji next().

   ```python
   my_list = [1, 2, 3, 4, 5]
   my_iter = iter(my_list)

   print(next(my_iter))  # 1
   print(next(my_iter))  # 2
   ```

# L

1. **len()** - służy do zwracania długości (ilości elementów) sekwencji, takiej jak lista, krotka, ciąg znaków, słownik czy zbiór.

   ```python
   my_list = [1, 2, 3, 4, 5]
   length = len(my_list)
   print(length)  # 5

   my_string = "Hello, World!"
   length = len(my_string)
   print(length)  # 13
   ```

2. **list()** - służy do konwersji sekwencji (takiej jak krotka, ciąg znaków, zbiór) na listę. Tworzy nową listę zawierającą elementy sekwencji.

   ```python
   my_tuple = (1, 2, 3, 4, 5)
   my_list = list(my_tuple)
   print(my_list)  # [1, 2, 3, 4, 5]

   my_string = "Hello"
   my_list = list(my_string)
   print(my_list)  # ['H', 'e', 'l', 'l', 'o']
   ```

3. **locals()** - służy do zwracania słownika reprezentującego bieżący zakres lokalny. Słownik ten zawiera zmienne lokalne dostępne w bieżącym kontekście. Może być używana do odczytu wartości lub modyfikacji zmiennych lokalnych.

   ```python
   def my_function():
       x = 10
       y = 20
       print(locals())  # {'x': 10, 'y': 20}

   my_function()
   ```

# M

1. **map()** - służy do zastosowania określonej funkcji do każdego elementu sekwencji (takiej jak lista, krotka) i zwrócenia iteratora z wynikami. Funkcja map() przyjmuje dwa argumenty: funkcję i sekwencję.

   ```python
   def square(x):
       return x ** 2

   my_list = [1, 2, 3, 4, 5]
   squared_list = list(map(square, my_list))
   print(squared_list)  # [1, 4, 9, 16, 25]
   ```

2. **max()** - służy do zwracania największego elementu z sekwencji lub największej wartości spośród argumentów. Może być używana z sekwencjami takimi jak lista, krotka lub łańcuch znaków, a także z argumentami oddzielnymi przez przecinek.

   ```python
   my_list = [3, 5, 2, 1, 4]
   max_value = max(my_list)
   print(max_value)  # 5

   x = 10
   y = 7
   max_value = max(x, y)
   print(max_value)  # 10
   ```

3. **memoryview()** - służy do tworzenia obiektu pamięci (memory view) dla danego obiektu sekwencji (takiego jak lista, krotka, ciąg znaków). Obiekt pamięci umożliwia dostęp do danych sekwencji bez tworzenia nowej kopii.

   ```python
   my_list = [1, 2, 3, 4, 5]
   my_view = memoryview(my_list)

   print(my_view[0])  # 1
   print(my_view[2])  # 3
   ```

4. **min()** - służy do zwracania najmniejszego elementu z sekwencji lub najmniejszej wartości spośród argumentów. Może być używana z sekwencjami takimi jak lista, krotka lub łańcuch znaków, a także z argumentami oddzielnymi przez przecinek.

   ```python
   my_list = [3, 5, 2, 1, 4]
   min_value = min(my_list)
   print(min_value)  # 1

   x = 10
   y = 7
   min_value = min(x, y)
   print(min_value)  # 7
   ```

# N

1. **next()** - służy do pobierania kolejnego elementu z iteratora. Przyjmuje dwa argumenty: iterator i wartość domyślną (opcjonalnie). Wywołanie funkcji next() zwraca kolejny element iteratora. Jeśli iterator został wyczerpany, można podać wartość domyślną, która zostanie zwrócona.

   ```python
   my_list = [1, 2, 3, 4, 5]
   my_iter = iter(my_list)

   print(next(my_iter))  # 1
   print(next(my_iter))  # 2
   ```

# O

1. **object()** - służy do tworzenia nowych klas poprzez dziedziczenie.

   ```python
   class MyClass(object):
       pass
   ```

2. **oct()** - służy do konwersji liczby całkowitej na jej ósemkową reprezentację w postaci łańcucha znaków. Prefiks "0o" jest dołączany do wynikowego łańcucha, aby wskazać, że liczba jest w systemie ósemkowym.

   ```python
   x = 10
   oct_value = oct(x)
   print(oct_value)  # "0o12"
   ```

3. **open()** - służy do otwierania pliku w trybie odczytu lub zapisu. Przyjmuje dwa argumenty: ścieżkę do pliku i tryb otwarcia. Zwraca obiekt pliku, który można użyć do operacji na pliku.

   ```python
   file = open("myfile.txt", "r")  # Otwieranie pliku do odczytu

   content = file.read()  # Odczyt zawartości pliku
   print(content)

   file.close()  # Zamykanie pliku
   ```

4. **ord()** - służy do zwracania wartości całkowitej reprezentującej kod Unicode danego znaku. Przyjmuje jeden argument - znak.

   ```python
   print(ord('A'))  # 65
   print(ord('a'))  # 97
   ```

# P

1. **pow()** - służy do podnoszenia liczby do określonej potęgi. Przyjmuje dwa lub trzy argumenty: podstawę, wykładnik i opcjonalnie modulo. Zwraca wynik podniesienia podstawy do potęgi.

   ```python
   result = pow(2, 3)
   print(result)  # 8

   result = pow(2, 3, 5)  # Podniesienie 2 do potęgi 3, a następnie modulo 5
   print(result)  # 3
   ```

2. **print()** - służy do wyświetlania tekstu lub wartości na standardowym wyjściu (zazwyczaj na konsoli). Może przyjmować jeden lub więcej argumentów, które zostaną wypisane oddzielone spacjami.

   ```python
   name = "John"
   age = 30

   print("My name is", name, "and I am", age, "years old.")
   ```

3. **property()** - służy do tworzenia atrybutów właściwości (property) dla klas. Atrybut właściwości umożliwia kontrolę dostępu do atrybutu klasy poprzez zdefiniowanie metod do pobierania (getter), ustawiania (setter) i usuwania (deleter) wartości atrybutu.

   ```python
   class Person:
       def __init__(self, name):
           self._name = name

       def get_name(self):
           return self._name

       def set_name(self, value):
           self._name = value

       def del_name(self):
           del self._name

       name = property(get_name, set_name, del_name)

   person = Person("John")
   print(person.name)  # Wywołanie gettera
   person.name = "Mike"  # Wywołanie settera
   print(person.name)  # Wywołanie gettera po zmianie wartości
   del person.name  # Wywołanie deletera
   ```

# R

1. **range()** - służy do generowania sekwencji liczb. Przyjmuje jeden, dwa lub trzy argumenty: start, stop (opcjonalny) i krok (opcjonalny). Zwraca obiekt typu range, który można iterować lub przekonwertować na inną sekwencję.

   ```python
   my_range = range(1, 6)
   for num in my_range:
       print(num)  # 1, 2, 3, 4, 5

   my_range = range(1, 10, 2)
   my_list = list(my_range)
   print(my_list)  # [1, 3, 5, 7, 9]
   ```

2. **repr()** - służy do zwracania reprezentacji obiektu w postaci łańcucha znaków. Zwracany łańcuch jest zazwyczaj kodem Pythona, który można użyć do odtworzenia obiektu.

   ```python
   x = 10
   repr_str = repr(x)
   print(repr_str)  # '10'
   ```

3. **reversed()** - służy do odwracania sekwencji, takiej jak lista, krotka czy łańcuch znaków. Zwraca iterator, który generuje elementy sekwencji w odwrotnej kolejności.

   ```python
   my_list = [1, 2, 3, 4, 5]
   reversed_list = list(reversed(my_list))
   print(reversed_list)  # [5, 4, 3, 2, 1]

   my_string = "Hello"
   reversed_string = "".join(reversed(my_string))
   print(reversed_string)  # "olleH"
   ```

4. **round()** - służy do zaokrąglania liczby do określonej liczby miejsc po przecinku. Przyjmuje dwa argumenty: liczbę i opcjonalnie liczbę miejsc po przecinku (domyślnie 0). Zwraca zaokrągloną wartość.

   ```python
   x = 3.14159
   rounded = round(x)
   print(rounded)  # 3

   y = 4.56789
   rounded = round(y, 2)
   print(rounded)  # 4.57
   ```

# S

1. **set()** - służy do tworzenia zbioru, czyli kolekcji unikalnych elementów. Może być używana do konwersji innych sekwencji, takich jak lista czy krotka, na zbiór.

   ```python
   my_list = [1, 2, 2, 3, 3, 3]
   my_set = set(my_list)
   print(my_set)  # {1, 2, 3}

   my_tuple = (1, 2, 3)
   my_set = set(my_tuple)
   print(my_set)  # {1, 2, 3}
   ```

2. **setattr()** - służy do ustawiania wartości atrybutu dla danego obiektu. Przyjmuje trzy argumenty: obiekt, nazwę atrybutu jako łańcuch znaków i wartość, która ma zostać przypisana do atrybutu.

   ```python
   class Person:
       pass

   person = Person()
   setattr(person, "name", "John")
   print(person.name)  # "John"
   ```

3. **slice()** - służy do tworzenia obiektu typu slice, który reprezentuje zakres indeksów sekwencji. Może być używana do pobierania fragmentów sekwencji.

   ```python
   my_list = [1, 2, 3, 4, 5]
   my_slice = slice(1, 4)
   sublist = my_list[my_slice]
   print(sublist)  # [2, 3, 4]
   ```

4. **sorted()** - służy do sortowania sekwencji, takiej jak lista, w porządku rosnącym. Zwraca nową listę zawierającą posortowane elementy.

   ```python
   my_list = [3, 1, 4, 2, 5]
   sorted_list = sorted(my_list)
   print(sorted_list)  # [1, 2, 3, 4, 5]
   ```

5. **staticmethod()** - służy do deklarowania metody statycznej w klasie. Metoda statyczna jest związana z klasą, a nie z instancją obiektu. Może być wywoływana bez konieczności tworzenia obiektu danej klasy.

   ```python
   class MathUtils:
       @staticmethod
       def add(x, y):
           return x + y

   result = MathUtils.add(3, 4)
   print(result)  # 7
   ```

6. **str()** - służy do konwersji obiektu na jego reprezentację jako łańcuch znaków.

   ```python
   x = 10
   str_value = str(x)
   print(str_value)  # "10"
   ```

7. **sum()** - służy do obliczania sumy elementów sekwencji numerycznej. Może być używana z listami, krotkami czy zbiorami zawierającymi liczby.

   ```python
   my_list = [1, 2, 3, 4, 5]
   total = sum(my_list)
   print(total)  # 15
   ```

8. **super()** - służy do odwoływania się do nadklasy w hierarchii dziedziczenia. Może być używana wewnątrz metody klasy, aby odwołać się do metody zdefiniowanej w nadklasie.

   ```python
   class Vehicle:
       def start_engine(self):
           print("Engine started")

   class Car(Vehicle):
         def start_engine(self):
            super().start_engine()
            print("Car engine started")

   my_car = Car()
   my_car.start_engine()
   # Output:
   # Engine started
   # Car engine started
   ```

# T

1. **tuple()** - służy do tworzenia krotki, czyli niemutowalnej sekwencji elementów. Może być używana do konwersji innych sekwencji, takich jak lista czy łańcuch znaków, na krotkę.

   ```python
   my_list = [1, 2, 3]
   my_tuple = tuple(my_list)
   print(my_tuple)  # (1, 2, 3)

   my_string = "Hello"
   my_tuple = tuple(my_string)
   print(my_tuple)  # ('H', 'e', 'l', 'l', 'o')
   ```

2. **type()** - służy do zwracania typu obiektu. Może być używana do sprawdzania typu obiektu lub tworzenia nowych klas dynamicznie.

   ```python
   x = 10
   print(type(x))  # <class 'int'>

   class MyClass:
       pass

   obj = MyClass()
   print(type(obj))  # <class '__main__.MyClass'>
   ```

# V

1. **vars()** - służy do zwracania słownika zawierającego atrybuty i wartości atrybutów danego obiektu. Może być używana do pobierania informacji o atrybutach obiektu.

   ```python
   class Person:
       def __init__(self, name, age):
           self.name = name
           self.age = age

   person = Person("John", 30)
   attributes = vars(person)
   print(attributes)  # {'name': 'John', 'age': 30}
   ```

# Z

1. **zip()** - służy do tworzenia iteratora, który agreguje elementy z dwóch lub więcej sekwencji. Zwraca iterator, który generuje krotki zawierające kolejne elementy z każdej sekwencji.

   ```python
   names = ["John", "Mike", "Anna"]
   ages = [30, 25, 35]

   zipped = zip(names, ages)
   zipped_list = list(zipped)
   print(zipped_list)  # [('John', 30), ('Mike', 25), ('Anna', 35)]
   ```

https://cheatography.com/davechild/cheat-sheets/python/

https://www.programiz.com/python-programming/iterator

# "Is" Vs "=="

<!-- Operator "is" a operator "==" są używane w Pythonie do porównywania obiektów, ale różnią się w działaniu:

Operator "is" sprawdza, czy dwie referencje wskazują na ten sam obiekt w pamięci. Oznacza to, że porównuje on tożsamość obiektów, a nie ich wartości. Zwróci wartość True, jeśli obie referencje wskazują na ten sam obiekt, a False, jeśli wskazują na różne obiekty.

Operator "==" porównuje wartości dwóch obiektów. Oznacza to, że porównuje on zawartość obiektów, a nie ich tożsamość. Zwróci wartość True, jeśli wartości obu obiektów są równe, a False, jeśli są różne.

Przykładowe użycie operatora "is":

python
Copy code
a = [1, 2, 3]
b = a
c = [1, 2, 3]

print(a is b)  # True - a i b wskazują na ten sam obiekt w pamięci
print(a is c)  # False - a i c wskazują na różne obiekty w pamięci
Przykładowe użycie operatora "==":

python
Copy code
a = [1, 2, 3]
b = [1, 2, 3]
c = [1, 2, 3]

print(a == b)  # True - wartości a i b są równe
print(a == c)  # True - wartości a i c są równe
Podsumowując, operator "is" porównuje tożsamość obiektów, podczas gdy operator "==" porównuje ich wartości. W większości przypadków, szczególnie gdy porównujesz liczby, łańcuchy znaków lub inne niemutowalne obiekty, zalecane jest stosowanie operatora "==". Natomiast operator "is" jest przydatny, gdy chcesz sprawdzić, czy dwie referencje wskazują na dokładnie ten sam obiekt w pamięci. -->

1. Operator "is" sprawdza, czy dwie referencje wskazują na ten sam obiekt w pamięci. Oznacza to, że porównuje on tożsamość obiektów, a nie ich wartości. Zwróci wartość True, jeśli obie referencje wskazują na ten sam obiekt, a False, jeśli wskazują na różne obiekty.

2. Operator "==" porównuje wartości dwóch obiektów. Oznacza to, że porównuje on zawartość obiektów, a nie ich tożsamość. Zwróci wartość True, jeśli wartości obu obiektów są równe, a False, jeśli są różne.

3. Przykładowe użycie operatora "is":

   ```python
   a = [1, 2, 3]
   b = a
   c = [1, 2, 3]

   print(a is b)  # True - a i b wskazują na ten sam obiekt w pamięci
   print(a is c)  # False - a i c wskazują na różne obiekty w pamięci
   ```

4. Przykładowe użycie operatora "==":

   ```python
   a = [1, 2, 3]
   b = [1, 2, 3]
   c = [1, 2, 3]

   print(a == b)  # True - wartości a i b są równe
   print(a == c)  # True - wartości a i c są równe
   ```

# Walrus Operator - Operator Przypisania w Warunku

1. **Walrus Operator**, znany również jako operator przypisania w warunku (ang. assignment expression), to operator wprowadzony w Pythonie 3.8, który umożliwia przypisanie wartości do zmiennej wewnątrz wyrażenia.

2. Operator ten wykorzystuje dwukropek, za którym znajduje się wyrażenie, a następnie operator przypisania ":=". Wyrażenie po lewej stronie operatora ":=" jest ewaluowane, a jego wartość jest przypisywana do zmiennej po prawej stronie.

3. Przykład użycia walrus operatora:

   ```python
      # Przykład 1:
      while (line := input()) != "koniec":
          print(line)

      while user_input := input("Wpisz coś: "):
         print(f">>> {user_input}")
      else:
         print("Koniec")
      # Dopuki pusty string nie zostanie wprowadzony, pętla będzie działać.

      # Przykład 2:
      if (n := len(my_list)) > 0:
          print(f"Lista zawiera {n} elementów.")

      # Przykład 3:
      data = [x for x in some_generator() if (y := process(x)) is not None]
   ```

   W powyższych przykładach:

   - Przykład 1 używa walrus operatora, aby przypisać wartość zwróconą przez funkcję input() do zmiennej line, jednocześnie sprawdzając, czy jest różna od "koniec". Jeśli tak, pętla while kontynuuje wykonanie.

   - Przykład 2 używa walrus operatora, aby przypisać długość listy my_list do zmiennej n i następnie sprawdza, czy n jest większe od zera. Jeśli tak, drukuje informację o liczbie elementów w liście.

   - Przykład 3 wykorzystuje walrus operatora w składni list comprehension, aby przypisać wartość zwracaną przez funkcję process(x) do zmiennej y, jednocześnie filtrując elementy na podstawie tego warunku.

4. Walrus Operator jest użyteczny w przypadkach, gdy chcemy przypisać wartość do zmiennej wewnątrz wyrażenia warunkowego lub iteracyjnego, jednocześnie unikając powtarzania kodu lub wywoływania funkcji wielokrotnie. Jednak należy go używać z umiarem, aby nie utrudniać czytelności kodu.

```python
def get_info(text: str) -> str:
    return {'text': text,
            'length': (length := len(text.replace(' ', ''))),
            'words': (words := text.split(' ')),
            'total_words': (words_length := len(words)),
            'avg_word_length': round(length / words_length, 2)}


print(get_info('Mateusz lubi Pythona, i co z tego, że jest trudny?'))
# {'text': 'Mateusz lubi Pythona, i co z tego, że jest trudny?', 'length': 41, 'words': ['Mateusz', 'lubi', 'Pythona,', 'i', 'co', 'z', 'tego,', 'że', 'jest', 'trudny?'], 'total_words': 10, 'avg_word_length': 4.1}

```

# @dataclass

Anotation @dataclass w języku Python jest dekoratorem wbudowanym w moduł dataclasses, który umożliwia szybkie tworzenie klas zawierających automatyczne generowanie kodu dla różnych funkcji specjalnych, takich jak **init**, **repr**, **eq**, itp. Użycie dekoratora @dataclass pozwala skrócić i uprościć implementację takich klas.

Aby skorzystać z dekoratora @dataclass, należy najpierw zaimportować go z modułu dataclasses:

```python
from dataclasses import dataclass
```

Następnie możemy zadekorować klasę, która ma być zdefiniowana jako "data class", używając adnotacji @dataclass przed definicją klasy. Wewnątrz klasy można zadeklarować pola (zmienne) i dostosować ich zachowanie poprzez dodawanie adnotacji typów lub specjalnych atrybutów.

Przykład użycia @dataclass:

```python
from dataclasses import dataclass

@dataclass
class Person:
    name: str
    age: int
    city: str = "Unknown"
```

W powyższym przykładzie klasa Person została zadekorowana adnotacją @dataclass. Pola klasy to name, age i opcjonalne pole city, które ma domyślną wartość "Unknown". Dzięki użyciu @dataclass automatycznie generowane są metody specjalne takie jak **init**, **repr**, **eq**, które są przydatne przy tworzeniu, reprezentacji i porównywaniu obiektów klasy.

Użycie @dataclass pozwala uniknąć pisania powtarzającego się kodu dla tych funkcji specjalnych, co przyspiesza i ułatwia tworzenie klas danych.

Warto zaznaczyć, że @dataclass jest dostępny od Pythona 3.7.

```python
from dataclasses import dataclass

@dataclass(frozen=True)
class Point:
    x: int
    y: int

p = Point(1, 2)
print(p)  # Point(x=1, y=2)

# Próba zmiany wartości pól (spowoduje błąd):
p.x = 5  # Raises FrozenInstanceError
```

2. **slots=True** - Atrybut slots pozwala na zoptymalizowanie zarządzania pamięcią dla obiektów klasy danych. Przez ustawienie slots=True w dekoratorze @dataclass, tworzona jest lista nazw pól, która jest przechowywana jako atrybut klasy. Oznacza to, że obiekty tej klasy będą przechowywały tylko pola, które są zadeklarowane w klasie, co oszczędza miejsce w pamięci. Jednakże, zastosowanie slots oznacza, że nie można dodawać ani usuwać pól dynamicznie po utworzeniu obiektu.

Przykład:

```python
from dataclasses import dataclass

@dataclass(slots=True)
class Person:
    name: str
    age: int

p = Person("Alice", 25)
print(p)  # Person(name='Alice', age=25)

# Próba dodania nowego pola (spowoduje błąd):
p.city = "New York"  # Raises AttributeError
```

Użycie **frozen=True** jest przydatne, gdy chcemy, aby obiekty były niemutowalne i traktowane jako wartości, podczas gdy **slots=True** jest przydatne, gdy chcemy zoptymalizować zużycie pamięci dla obiektów klasy danych, szczególnie gdy tworzymy dużą liczbę takich obiektów. W obu przypadkach należy zwrócić uwagę na ograniczenia i zachowanie związane z użyciem tych atrybutów.

3. **kw_only=True** - Atrybut kw_only pozwala na zdefiniowanie, że wszystkie pola klasy danych są argumentami nazwanymi. Oznacza to, że nie można przekazywać argumentów pozycyjnych do konstruktora klasy danych, a jedynie argumenty nazwane. Domyślnie, jeśli nie użyjemy kw_only=True, to wszystkie pola klasy danych są argumentami pozycyjnymi.

Przykład:

```python
from dataclasses import dataclass

@dataclass(kw_only=True)
class Person:
   name: str
   age: int

p = Person("Alice", 25)  # Raises TypeError
p = Person(name="Alice", age=25)  # OK
```

4. **order=True** - Atrybut order pozwala na zdefiniowanie, że pola klasy danych są porównywalne i mogą być sortowane. Domyślnie, jeśli nie użyjemy order=True, to pola klasy danych nie są porównywalne i nie mogą być sortowane.

Przykład:

```python
from dataclasses import dataclass

@dataclass(order=True)
class Person:
   name: str
   age: int

p1 = Person("Alice", 25)
p2 = Person("Bob", 30)
p3 = Person("Alice", 30)

print(p1 < p2)  # True
print(p1 < p3)  # True
print(p2 < p3)  # False
```

Zastosowanie z json, łatwiejsze tworzenie obiektów z jsona i zarządzanie nimi.

```python
   from dataclasses import dataclass


   @dataclass(slots=True)
   class Person:
      name: str
      age: int
      job: str = None
      friends: list[str] = None

      def __str__(self):
         return f"{self.name} is {self.age} years old and works as a {self.job}, friends: {self.friends}."


   json: dict = {
      'name': 'John',
      'age': 30,
      'job': 'developer',
      'friends': ['Anna', 'Peter']
   }

   johm = Person(**json) # **json - rozpakowanie słownika
   print(johm)
   # John is 30 years old and works as a developer, friends: ['Anna', 'Peter'].

   print(johm.name) # John
   print(johm.age) # 30
   print(johm.job) # developer
   print(johm.friends) # ['Anna', 'Peter']
```

```python
   from dataclasses import dataclass, field

   @dataclass(frozen=True, order=True)  # Klasa danych, obiekty są niemutowalne i mają funkcjonalność porównywania i sortowania
   class Comment:
      id: int = field()  # Pole id typu int bez wartości domyślnej

      text: str = field(default="")  # Pole text typu str z wartością domyślną ""

      replies: list[int] = field(default_factory=list, compare=False, hash=False, repr=False)
      # Pole replies typu list[int] z wartością domyślną jako nowa pusta lista
      # Porównywanie, skrót (hash) i reprezentacja tekstowa nie uwzględniają tego pola

   # Przykład użycia

   comment1 = Comment(id=1, text="First comment")  # Tworzenie obiektu klasy Comment z podanymi wartościami
   comment2 = Comment(id=2, text="Second comment", replies=[3, 4, 5])  # Tworzenie obiektu z dodatkowymi polami

   print(comment1)  # Comment(id=1, text='First comment', replies=[])
   print(comment2)  # Comment(id=2, text='Second comment', replies=[3, 4, 5])

   # Porównywanie obiektów klasy Comment
   print(comment1 == comment2)  # False
   print(comment1 < comment2)  # True

   # Próba modyfikacji niemutowalnego obiektu (spowoduje błąd)
   comment1.text = "Modified"  # Raises FrozenInstanceError
```

# Generators

1. **Generatory** - Generatory są funkcjami specjalnymi, które wytwarzają sekwencję wartości w trakcie iteracji, zamiast tworzyć całą sekwencję upfront. Aby zdefiniować generator, używamy słowa kluczowego yield zamiast return w ciele funkcji. Gdy funkcja zawiera instrukcję yield, staje się generatorem. Generatory zachowują swój stan w trakcie iteracji, co oznacza, że pamiętają miejsce, w którym zostali zatrzymani i wznawiają swoje wykonanie od tego miejsca przy kolejnym żądaniu.

```python
   def even_numbers(n):
      for i in range(n):
         if i % 2 == 0:
            yield i # Zwraca tylko 1 - kolejną wartość

   # Użycie generatora
   evens = even_numbers(10)
   for num in evens:
      print(num)
```

2. **Generator Expressions** - Generator Expressions są podobne do list comprehensions, ale zwracają generator zamiast listy. Generator Expressions są wyrażeniami, które generują sekwencję wartości, zamiast tworzyć całą sekwencję upfront. Generator Expressions są szczególnie przydatne w sytuacjach, gdy musimy generować lub przetwarzać duże ilości danych sekwencyjnie, ale nie chcemy przechowywać wszystkich danych w pamięci naraz.

```python
   # Generator Expression
   evens = (i for i in range(10) if i % 2 == 0)

   # Użycie generatora
   for num in evens:
      print(num)
```

# Delete

<!-- W języku Python, delete to słowo kluczowe używane do usuwania obiektów lub zmiennych z pamięci. Usunięcie obiektu lub zmiennej oznacza, że przestaje być dostępny i zajmować miejsce w pamięci, co może być przydatne w celu zwalniania zasobów lub zarządzania pamięcią.

Możemy użyć słowa kluczowego del do usunięcia zmiennej. Oto przykład:

python
Copy code
x = 10
print(x)  # 10

del x
print(x)  # NameError: name 'x' is not defined
W powyższym przykładzie, po usunięciu zmiennej x za pomocą del, próba uzyskania dostępu do zmiennej x spowoduje błąd NameError, ponieważ zmienna nie istnieje.

Możemy również użyć del do usuwania elementów z list, słowników, zbiorów itp. Oto przykład:

python
Copy code
my_list = [1, 2, 3, 4, 5]
del my_list[2]  # Usunięcie elementu o indeksie 2

print(my_list)  # [1, 2, 4, 5]

my_dict = {'a': 1, 'b': 2, 'c': 3}
del my_dict['b']  # Usunięcie elementu o kluczu 'b'

print(my_dict)  # {'a': 1, 'c': 3}
W powyższych przykładach, używając del z odpowiednim indeksem lub kluczem, możemy usunąć odpowiednie elementy z listy i słownika.

Pamiętaj, że del jest używane do usuwania obiektów lub zmiennych z pamięci, ale nie jest to zalecane w przypadku standardowych zmiennych lub obiektów, które są automatycznie zarządzane przez mechanizmy odśmiecania pamięci (garbage collector). W większości przypadków nie jest konieczne manualne usuwanie zmiennych, ponieważ Python sam zarządza pamięcią i usuwa nieużywane obiekty w odpowiednim czasie. del jest bardziej przydatne w przypadku usuwania specyficznych elementów z kontenerów lub w sytuacjach, gdy chcemy świadomie zwolnić określone zasoby. -->

1. **Delete** - Delete to słowo kluczowe używane do usuwania obiektów lub zmiennych z pamięci. Usunięcie obiektu lub zmiennej oznacza, że przestaje być dostępny i zajmować miejsce w pamięci, co może być przydatne w celu zwalniania zasobów lub zarządzania pamięcią.

```python
   x = 10
   print(x)  # 10

   del x
   print(x)  # NameError: name 'x' is not defined
```

2. **Delete** - Możemy również użyć del do usuwania elementów z list, słowników, zbiorów, obiektów klasowych itp. Oto przykład:

```python
   my_list = [1, 2, 3, 4, 5]
   del my_list[2]  # Usunięcie elementu o indeksie 2

   print(my_list)  # [1, 2, 4, 5]

   my_dict = {'a': 1, 'b': 2, 'c': 3}
   del my_dict['b']  # Usunięcie elementu o kluczu 'b'

   print(my_dict)  # {'a': 1, 'c': 3}
```

Pamiętaj, że del jest używane do usuwania obiektów lub zmiennych z pamięci, ale nie jest to zalecane w przypadku standardowych zmiennych lub obiektów, które są automatycznie zarządzane przez mechanizmy odśmiecania pamięci (garbage collector). W większości przypadków nie jest konieczne manualne usuwanie zmiennych, ponieważ Python sam zarządza pamięcią i usuwa nieużywane obiekty w odpowiednim czasie. del jest bardziej przydatne w przypadku usuwania specyficznych elementów z kontenerów lub w sytuacjach, gdy chcemy świadomie zwolnić określone zasoby.

# Assert

<!-- W języku Python, assert to instrukcja używana do sprawdzania warunków i weryfikowania, czy są one prawdziwe. Jeśli warunek jest fałszywy, to generowany jest wyjątek AssertionError.

Składnia assert jest następująca:

python
Copy code
assert warunek, komunikat
warunek jest wyrażeniem, które zostanie sprawdzone. Jeśli jest prawdziwe (ma wartość True), to program kontynuuje działanie. Jeśli jest fałszywe (ma wartość False), to generowany jest wyjątek AssertionError.

komunikat jest opcjonalnym argumentem, który można podać, aby dostarczyć dodatkowy opis błędu. Jest to zazwyczaj łańcuch znaków lub wyrażenie, które będzie wyświetlone w przypadku wystąpienia błędu. Ten argument jest przydatny w celu dostarczenia informacji diagnostycznych, które pomogą zlokalizować przyczynę błędu.

Oto prosty przykład użycia instrukcji assert:

python
Copy code
x = 5
assert x > 0, "x musi być większe od zera"
print("Kod wykonuje się dalej")

y = 0
assert y != 0, "y nie może być równa zero"
print("Ten komunikat się nie wyświetli, ponieważ poprzedni assert wywołał błąd")
W powyższym przykładzie, pierwszy assert sprawdza warunek x > 0. Jeśli warunek jest fałszywy, to generowany jest AssertionError z podanym komunikatem. W przeciwnym razie, jeśli warunek jest prawdziwy, program kontynuuje działanie.

Drugi assert sprawdza warunek y != 0. Ponieważ ten warunek jest fałszywy, generowany jest AssertionError i dalsza część kodu nie jest wykonywana.

assert jest przydatny w procesie debugowania i testowania kodu, ponieważ pozwala na sprawdzanie założeń i przewidywanie nieprawidłowych stanów. Jednak pamiętaj, że instrukcje assert są zazwyczaj wykorzystywane do sprawdzania założeń wewnętrznych, a nie jako mechanizm obsługi błędów dla użytkownika końcowego. W przypadku produkcji kodu, zaleca się stosowanie bardziej odpowiednich mechanizmów obsługi błędów. -->

1. **Assert** - Assert to instrukcja używana do sprawdzania warunków i weryfikowania, czy są one prawdziwe. Jeśli warunek jest fałszywy, to generowany jest wyjątek AssertionError.

```python
   assert warunek, komunikat


   x = 5
   assert x > 0, "x musi być większe od zera"
   print("Kod wykonuje się dalej")

   y = 0
   assert y != 0, "y nie może być równa zero"
   print("Ten komunikat się nie wyświetli, ponieważ poprzedni assert wywołał błąd")
```

**assert** jest przydatny w procesie debugowania i testowania kodu, ponieważ pozwala na sprawdzanie założeń i przewidywanie nieprawidłowych stanów. Jednak pamiętaj, że instrukcje assert są zazwyczaj wykorzystywane do sprawdzania założeń wewnętrznych, a nie jako mechanizm obsługi błędów dla użytkownika końcowego. W przypadku produkcji kodu, zaleca się stosowanie bardziej odpowiednich mechanizmów obsługi błędów.

# Match-Case

1. **Match-Case** to nowa konstrukcja wprowadzona w języku Python w wersji 3.10, która służy do dopasowania wartości do różnych przypadków (pattern matching). Jest to alternatywna składnia do instrukcji warunkowych if-elif-else i umożliwia bardziej zwięzłe i czytelne dopasowanie wielu przypadków.

Oto ogólna składnia konstrukcji Match-Case:

```python
   match wyrażenie:
      case wartość1:
         # kod dla dopasowania wartość1
      case wartość2:
         # kod dla dopasowania wartość2
      case wartość3:
         # kod dla dopasowania wartość3
      ...
      case _:
         # kod dla przypadku domyślnego (jeśli żaden poprzedni przypadek nie został dopasowany)
```

Przykład:

```python
   def calculate(x, y, operator):
      match operator:
         case '+':
               result = x + y
               print(f"{x} + {y} = {result}")
         case '-':
               result = x - y
               print(f"{x} - {y} = {result}")
         case '*':
               result = x * y
               print(f"{x} * {y} = {result}")
         case '/':
               if y != 0:
                  result = x / y
                  print(f"{x} / {y} = {result}")
               else:
                  print("Nie można dzielić przez zero!")
         case _:
               print("Nieznany operator")

   calculate(5, 3, '+')  # 5 + 3 = 8
   calculate(5, 3, '-')  # 5 - 3 = 2
   calculate(5, 3, '*')  # 5 * 3 = 15
   calculate(5, 3, '/')  # 5 / 3 = 1.6666666666666667
   calculate(5, 0, '/')  # Nie można dzielić przez zero!
   calculate(5, 3, '%')  # Nieznany operator
```

Przkład 2:

```python
user_input: str = input("Command: ")
p_command: list[str] = user_input.split()
print(p_command)
match p_command:
    case['find', *images]:
        print(f'Find images: {images}')
    case['download', *images]:
        print(f'Download images: {images}')
    case['cancel', *images]:
        print(f'Cancel images: {images}') if len(images) > 1
    case _:
        print('Unknown command')

   # Command: find lol
   # ['find', 'lol']
   # Find images: ['lol']
```

<!--
Dekoratory
Dekoratory (decorators) w języku Python to zaawansowany mechanizm umożliwiający modyfikowanie zachowania funkcji lub klas poprzez opakowywanie ich w inny kod. Dekoratory są funkcjami, które przyjmują inną funkcję jako argument i zwracają zmodyfikowaną wersję tej funkcji.

Oto przykład prostej definicji dekoratora:

python
Copy code
def my_decorator(func):
    def wrapper():
        print("Przed wykonaniem funkcji")
        func()
        print("Po wykonaniu funkcji")
    return wrapper
W powyższym przykładzie mamy dekorator my_decorator, który przyjmuje funkcję func jako argument. Definiujemy również wewnętrzną funkcję wrapper, która dodaje dodatkową logikę przed i po wykonaniu funkcji func.

Aby zastosować dekorator do konkretnej funkcji, używamy składni @nazwa_dekoratora przed definicją funkcji, którą chcemy zmodyfikować. Oto przykład użycia dekoratora my_decorator:

python
Copy code
@my_decorator
def my_function():
    print("To jest moja funkcja")

my_function()
Wywołanie funkcji my_function() spowoduje wykonanie dekorowanej wersji tej funkcji, która dodaje dodatkowy kod przed i po wykonaniu funkcji. Efekt działania powyższego kodu będzie następujący:

css
Copy code
Przed wykonaniem funkcji
To jest moja funkcja
Po wykonaniu funkcji
Dekoratory są potężnym narzędziem w języku Python i mają wiele zastosowań. Mogą służyć do:

Modyfikowania zachowania funkcji, np. dodawanie logiki przed i po wykonaniu funkcji, sprawdzanie warunków przed wykonaniem funkcji, dodawanie metadanych do funkcji itp.
Tworzenia klas dekoratorów, które mogą być używane do dekorowania zarówno funkcji, jak i klas.
Kontrolowania dostępu do funkcji, np. sprawdzanie uprawnień przed wykonaniem funkcji.
Tworzenia rozszerzeń i modułów w języku Python.
W języku Python istnieje wiele wbudowanych dekoratorów oraz gotowych dekoratorów dostępnych w różnych bibliotekach. Ponadto, możemy również tworzyć własne dekoratory, dostosowane do naszych indywidualnych potrzeb. -->

# Dekoratory (decorators)

1. **Dekoratory** (decorators) w języku Python to zaawansowany mechanizm umożliwiający modyfikowanie zachowania funkcji lub klas poprzez opakowywanie ich w inny kod. Dekoratory są funkcjami, które przyjmują inną funkcję jako argument i zwracają zmodyfikowaną wersję tej funkcji.

Oto przykład prostej definicji dekoratora:

```python
   def my_decorator(func):
      def wrapper():
         print("Przed wykonaniem funkcji")
         func()
         print("Po wykonaniu funkcji")
      return wrapper
```

W powyższym przykładzie mamy dekorator my_decorator, który przyjmuje funkcję func jako argument. Definiujemy również wewnętrzną funkcję wrapper, która dodaje dodatkową logikę przed i po wykonaniu funkcji func.

Aby zastosować dekorator do konkretnej funkcji, używamy składni @nazwa_dekoratora przed definicją funkcji, którą chcemy zmodyfikować. Oto przykład użycia dekoratora my_decorator:

```python
   @my_decorator
   def my_function():
      print("To jest moja funkcja")

   my_function()
```

Wywołanie funkcji my_function() spowoduje wykonanie dekorowanej wersji tej funkcji, która dodaje dodatkowy kod przed i po wykonaniu funkcji. Efekt działania powyższego kodu będzie następujący:

```python
   Przed wykonaniem funkcji
   To jest moja funkcja
   Po wykonaniu funkcji
```

Dekoratory są potężnym narzędziem w języku Python i mają wiele zastosowań. Mogą służyć do:

- Modyfikowania zachowania funkcji, np. dodawanie logiki przed i po wykonaniu funkcji, sprawdzanie warunków przed wykonaniem funkcji, dodawanie metadanych do funkcji itp.
- Tworzenia klas dekoratorów, które mogą być używane do dekorowania zarówno funkcji, jak i klas.
- Kontrolowania dostępu do funkcji, np. sprawdzanie uprawnień przed wykonaniem funkcji.
- Tworzenia rozszerzeń i modułów w języku Python.

W języku Python istnieje wiele wbudowanych dekoratorów oraz gotowych dekoratorów dostępnych w różnych bibliotekach. Ponadto, możemy również tworzyć własne dekoratory, dostosowane do naszych indywidualnych potrzeb.

2.

```python
import time
from functools import wraps


def get_time(func):
   """Dekorator mierzący czas wykonania funkcji."""
    @wraps(func) # zachowuje nazwę funkcji
    def wrapper(*args, **kwargs):
        start_time: float = time.perf_counter()
        result = func(*args, **kwargs)
        end_time: float = time.perf_counter()

        total_time: float = round(end_time - start_time, 6)
        print(f'Total time: {total_time} s')

        return result

    return wrapper


@get_time
def calculate_sum(n: int) -> int:
    sum_result: int = 0
    for i in range(1, n+1):
        sum_result += i
        time.sleep(0.1)
    return sum_result


result: int = calculate_sum(20)
print("The sum is:", result)

# Total time: 2.005772 s
# The sum is: 210

```

3.

```python
from functools import wraps


def repeat_function(num_repeats):
    def decorator_repeat_function(func):
        @wraps(func)
        def wrapper_repeat_function(*args, **kwargs):
            for _ in range(num_repeats):
                result = func(*args, **kwargs)
            return result
        return wrapper_repeat_function
    return decorator_repeat_function


@repeat_function(5)
def write(num):
    print(num, end=' ')


def main():
    write(5)


if __name__ == '__main__':
    main()
```

# Memoization

Memoization jest techniką optymalizacji, która polega na zapisywaniu wyników obliczeń, aby uniknąć ich powtarzania dla tych samych argumentów. W Pythonie można to osiągnąć za pomocą dekoratora @functools.cache()

```python
import time
from functools import cache

@cache
def fib(n):
 if n < 2:
     return n
 return fib(n-1) + fib(n-2)

start = time.perf_counter()
print(fib(30))
end = time.perf_counter()
print(f"Total time: {end - start:0.4f} s")


def fib(n):
 if n < 2:
     return n
 return fib(n-1) + fib(n-2)

start = time.perf_counter()
print(fib(30))
end = time.perf_counter()
print(f"Total time: {end - start:0.4f} s")

# Wynik:
# 832040
# Total time: 0.0002468000166118145 s
# 832040
# Total time: 0.22834839997813106 s
```

Jeśli korzystasz z wersji Pythona starszej niż 3.9, możesz użyć functools.lru_cache() lub zaimplementować własne rozwiązanie memoizacji.

Przydatne w: rekurencja, obliczenia matematuczne składające się z wielu kroków, np. obliczanie silni, ciąg Fibonacciego, itp., funkcjie zależne od wewnętrznego stanu programu, ale nie zmiennych dla tych samych argumentów.

Jednak warto pamiętać, że memoizacja ma sens tylko dla funkcji, które mają deterministyczne działanie, czyli zawsze zwracają ten sam wynik dla tych samych argumentów. Jeśli funkcja ma efekty uboczne (np. modyfikuje stan zewnętrzny), memoizacja może prowadzić do nieprzewidywalnych wyników i błędów.

W każdym przypadku, zanim zdecydujesz się na zastosowanie memoizacji, warto zbadać, czy rzeczywiście przyniesie ona znaczną poprawę wydajności. W niektórych przypadkach, koszt przechowywania wyników w pamięci podręcznej może przewyższać korzyści z uniknięcia powtarzania obliczeń.

# Context Managers

1. Context Managers (zarządcy kontekstu) w Pythonie są używane do zarządzania zasobami, takimi jak pliki, połączenia sieciowe, bloki kodu krytyczne dla wątków itp. Zapewniają składnię blokową, która automatycznie zarządza otwarciem i zamknięciem zasobów, niezależnie od tego, czy kod został wykonany poprawnie, czy też wystąpił wyjątek.

2. W Pythonie istnieje kilka sposobów definiowania i używania context managerów:

- Za pomocą bloku with: Najpopularniejszym sposobem korzystania z context managerów jest użycie bloku with. Context manager definiuje metodę **enter**, która jest wywoływana na początku bloku with, i metodę **exit**, która jest wywoływana po opuszczeniu bloku with. Przykład:

```python
with open('plik.txt', 'r') as file:
    data = file.read()
    # Kod operujący na zawartości pliku
    # Nie musisz wywoływać file.close(), zostanie to wykonane automatycznie
```

- Dekoratory contextlib.contextmanager: Moduł contextlib dostarcza dekoratora contextmanager, który umożliwia definiowanie prostych context managerów za pomocą funkcji generatora. Przykład:

```python
from contextlib import contextmanager

@contextmanager
def open_file(filename, mode):
    file = open(filename, mode)
    try:
        yield file
    finally:
        file.close()

with open_file('plik.txt', 'r') as file:
      data = file.read()
      # Kod operujący na zawartości pliku
      # Nie musisz wywoływać file.close(), zostanie to wykonane automatycznie
```

- Klasa implementująca metody **enter** i **exit**: Możesz również zaimplementować własną klasę, która ma metody **enter** i **exit**, aby działała jako context manager. Przykład:

```python
class OpenFile:
    def __init__(self, filename, mode):
        self.filename = filename
        self.mode = mode
        self.file = None

    def __enter__(self):
        self.file = open(self.filename, self.mode)
        return self.file

    def __exit__(self, exc_type, exc_value, traceback):
        self.file.close()

with OpenFile('plik.txt', 'r') as file:
      data = file.read()
      # Kod operujący na zawartości pliku
      # Nie musisz wywoływać file.close(), zostanie to wykonane automatycznie
```

Niektóre zasoby, takie jak pliki, mają wbudowane context managery, które automatycznie zarządzają otwarciem i zamknięciem. Jednak warto samemu definiować context managera, jeśli potrzebujesz bardziej zaawansowanego zarządzania zasobami lub jeśli chcesz dostosować zachowanie zarządcy kontekstu do swoich potrzeb.

Dzięki context managerom w Pythonie możesz uniknąć powtarzającego się kodu związane z zarządzaniem zasobami i zapewnić poprawne i bezpieczne korzystanie z tych zasobów w twoim kodzie.

3.  - Pliki tekstowe:

```python
with open('plik.txt', 'r') as file:
    data = file.read()
    # Kod operujący na zawartości pliku
    # Nie musisz wywoływać file.close(), zostanie to wykonane automatycznie
```

- Połączenia sieciowe:

```python
import socket

with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sock:
    sock.connect(('localhost', 8080))
    # Kod operujący na połączeniu
    # Nie musisz wywoływać sock.close(), zostanie to wykonane automatycznie
```

- Transakcje bazodanowe:

```python
import sqlite3

class DatabaseTransaction:
    def __init__(self, db_file):
        self.db_file = db_file
        self.connection = None

    def __enter__(self):
        self.connection = sqlite3.connect(self.db_file)
        self.connection.execute("BEGIN")
        return self.connection

    def __exit__(self, exc_type, exc_value, traceback):
        if exc_type:
            self.connection.execute("ROLLBACK")
        else:
            self.connection.execute("COMMIT")
        self.connection.close()

# Użycie context managera do transakcji bazodanowej

with DatabaseTransaction('mydb.db') as db:
    db.execute("INSERT INTO mytable (name) VALUES (?)", ('John',))
    db.execute("INSERT INTO mytable (name) VALUES (?)", ('Jane',))
    # Operacje na bazie danych w ramach transakcji
    # Transakcja zostanie automatycznie zatwierdzona lub wycofana w zależności od wyniku
```

- Mierzenie czasu wykonania bloku kodu:

```python
import time

class Timer:
    def __enter__(self):
        self.start_time = time.time()

    def __exit__(self, exc_type, exc_value, traceback):
        elapsed_time = time.time() - self.start_time
        print(f"Czas wykonania: {elapsed_time} sekundy")

with Timer():

      # Kod, którego czas wykonania chcemy zmierzyć
      time.sleep(2)
```

- Zmiana bieżącego katalogu roboczego:

```python
import os

class ChangeDir:
    def __init__(self, new_dir):
        self.new_dir = new_dir
        self.previous_dir = None

    def __enter__(self):
        self.previous_dir = os.getcwd()
        os.chdir(self.new_dir)

    def __exit__(self, exc_type, exc_value, traceback):
        os.chdir(self.previous_dir)

with ChangeDir('/path/to/new_directory'):

      # Kod operujący w nowym katalogu
      print(os.getcwd())  # Wyświetli ścieżkę do /path/to/new_directory

# Po opuszczeniu bloku `with`, katalog roboczy zostanie przywrócony do poprzedniego stanu
print(os.getcwd())  # Wyświetli ścieżkę przed blokiem `with`
```

- Przechwytywanie i obsługa wyjątków:

```python
class ExceptionHandler:
    def __enter__(self):
        pass

    def __exit__(self, exc_type, exc_value, traceback):
        if exc_type is not None:
            print(f"Wystąpił wyjątek: {exc_type}: {exc_value}")
            # Dodatkowe operacje obsługi wyjątku, jeśli potrzeba

with ExceptionHandler():

      # Kod, który może zgłosić wyjątek
      x = 10 / 0  # Dzielenie przez zero

# Jeśli wystąpił wyjątek, zostanie wyświetlony komunikat, ale nie zatrzyma to wykonania programu

```

- Blokowanie pliku do zapisu:

```python
class FileLock:
    def __init__(self, file_path):
        self.file_path = file_path
        self.file = None

    def __enter__(self):
        self.file = open(self.file_path, 'w')
        self.file.write("Lock acquired")
        return self.file

    def __exit__(self, exc_type, exc_value, traceback):
        self.file.close()
        # Dodatkowe operacje zwalniania blokady pliku, jeśli potrzeba

# Użycie context managera do blokowania pliku

with FileLock('locked_file.txt') as file:

      # Kod operujący na zablokowanym pliku
      file.write("Data to be written")
      # Inne operacje na pliku

# Po opuszczeniu bloku `with`, plik zostanie automatycznie zamknięty

```

- Blokowanie wątku:

```python
class FileLock:
    def __init__(self, file_path):
        self.file_path = file_path
        self.file = None

    def __enter__(self):
        self.file = open(self.file_path, 'w')
        self.file.write("Lock acquired")
        return self.file

    def __exit__(self, exc_type, exc_value, traceback):
        self.file.close()
        # Dodatkowe operacje zwalniania blokady pliku, jeśli potrzeba

# Użycie context managera do blokowania pliku
with FileLock('locked_file.txt') as file:
    # Kod operujący na zablokowanym pliku
    file.write("Data to be written")
    # Inne operacje na pliku

# Po opuszczeniu bloku `with`, plik zostanie automatycznie zamknięty

```

- Przykład użycia zewnętrznego modułu jako context managera (requests):

```python
import requests

class APIClient:
    def __init__(self, base_url):
        self.base_url = base_url

    def __enter__(self):
        self.session = requests.Session()
        return self.session

    def __exit__(self, exc_type, exc_value, traceback):
        self.session.close()

# Użycie context managera do wykonywania żądań HTTP

with APIClient('https://api.example.com') as client:

      response = client.get('/users')
      # Kod obsługujący odpowiedź

# Po opuszczeniu bloku `with`, sesja zostanie automatycznie zamknięta

```

# Monkey patching

Monkey patching w Pythonie odnosi się do dynamicznej zmiany lub rozszerzenia zachowania istniejących obiektów lub modułów w czasie działania programu. Pozwala na modyfikację kodu źródłowego w locie, bez konieczności zmiany pierwotnego kodu.

Przykład monkey patchingu może wyglądać tak:

```python
# Przed monkey patchingiem
class MyClass:
    def my_method(self):
        return "Original method"

# Monkey patching - dodanie nowej metody do klasy MyClass
def new_method(self):
    return "Patched method"

MyClass.my_method = new_method

# Po monkey patchingu
obj = MyClass()
print(obj.my_method())  # Wywołanie nowej metody: "Patched method"


```

# DOCstring

Docstring to ciąg dokumentacyjny (ang. docstring), który jest umieszczany wewnątrz definicji funkcji, klasy, modułu lub metody. Docstringi służą do opisywania działania i funkcjonalności kodu oraz są wykorzystywane przez narzędzia do generowania dokumentacji, takie jak Sphinx.

Docstringi są zwykle umieszczane jako pierwsza instrukcja po nagłówku definicji i są otoczone potrójnym cudzysłowem (""") na początku i na końcu. Mogą zawierać zarówno zwykły tekst, jak i specjalne znaczniki formatowania, takie jak Markdown lub reStructuredText, które są później przetwarzane na czytelną dokumentację.

Docstringi są zwykle umieszczane jako pierwsza instrukcja po nagłówku definicji i są otoczone potrójnym cudzysłowem (""") na początku i na końcu. Mogą zawierać zarówno zwykły tekst, jak i specjalne znaczniki formatowania, takie jak Markdown lub reStructuredText, które są później przetwarzane na czytelną dokumentację.

```python
def dodaj(a, b):
    """
    Funkcja dodaje dwie liczby.

    :param a: Pierwsza liczba.
    :param b: Druga liczba.
    :return: Suma dwóch liczb.
    """
    return a + b


   print(dodaj.__doc__)

   # Wynik:

   # Funkcja dodaje dwie liczby.

   # :param a: Pierwsza liczba.
   # :param b: Druga liczba.
   # :return: Suma dwóch liczb.

```

Przykładem fajnej dokumentacji jest dokumentacja biblioteki random, request, numpy.

# TWORZENIE DOKUMENTACJI W PYTHONIE

## Pisanie dokumentacji:

https://sphinx-rtd-tutorial.readthedocs.io/en/latest/docstrings.html

Przukład:

```python
"""[Summary]

:param [ParamName]: [ParamDescription], defaults to [DefaultParamVal]
:type [ParamName]: [ParamType](, optional)
...
:raises [ErrorType]: [ErrorDescription]
...
:return: [ReturnDescription]
:rtype: [ReturnType]
"""
```

## Sphinx - samouczek:

https://sphinx-rtd-tutorial.readthedocs.io/en/latest/sphinx-config.html#autodoc-configuration

Pisanie dobrej dokumentacji w Pythonie jest ważnym elementem tworzenia czytelnego i zrozumiałego kodu. Dobra dokumentacja pomaga innym programistom (w tym tobie w przyszłości) zrozumieć, jak korzystać z twojego kodu i jakie efekty można oczekiwać. Oto kilka wskazówek, jak napisać dobrą dokumentację w Pythonie:

1. Używaj docstringów: Wykorzystaj docstringi, czyli ciągi dokumentacyjne, aby opisać swoje funkcje, klasy, metody i moduły. Docstringi powinny być umieszczone zaraz pod nagłówkiem definicji i powinny być jasne, zwięzłe i czytelne.

2. Opis funkcji i metod: W docstringu funkcji i metod opisz, co robią, jakie parametry przyjmują, jakie zwracają wartości (jeśli takie są), oraz ewentualne wyjątki, które mogą być zgłaszane. Używaj jasnego i zrozumiałego języka, unikając nadmiernie technicznych terminów, jeśli to możliwe.

3. Używaj znaczników formatowania: Możesz używać znaczników formatowania w docstringach, takich jak reStructuredText lub Markdown, aby zwiększyć czytelność dokumentacji. Znaczniki takie jak :param, :return, :raises pomagają w strukturyzacji informacji.

4. Opis argumentów i zwracanych wartości: W opisie argumentów podaj ich nazwy, typy danych, a także krótki opis, co oznacza każdy argument. Jeśli funkcja zwraca wartość, opisz, co ta wartość oznacza i w jakim formacie jest zwracana.

5. Przykłady użycia: Dodaj przykłady użycia funkcji lub metody, aby pokazać, jak korzystać z danego elementu kodu. Przykłady mogą pomóc innym programistom zrozumieć, jakie argumenty przekazać i jak interpretować wyniki.

6. Opis modułów i klas: Jeśli piszesz moduł lub klasę, opisz ogólną funkcjonalność i zastosowanie modułu lub klasy. Wyjaśnij, jakie są główne składniki modułu lub klasy i jak z nich korzystać.

7. Aktualizuj dokumentację: Pamiętaj, aby aktualizować dokumentację w miarę wprowadzania zmian w kodzie. Jeśli dodajesz nowe funkcje, usuwasz lub zmieniasz istniejące, upewnij się, że odpowiednio aktualizujesz docstringi.

8. Korzystaj z narzędzi generujących dokumentację: Wykorzystaj narzędzia takie jak Sphinx do generowania automatycznej dokumentacji na podstawie docstringów w twoim kodzie. To ułatwia utrzymanie i publikację dokumentacji w postaci czytelnej strony internetowej lub pliku PDF.

Dobra dokumentacja jest niezwykle cenna dla współpracujących programistów i ułatwia korzystanie z twojego kodu. Inwestowanie czasu i wysiłku w pisanie czytelnej dokumentacji przynosi długoterminowe korzyści i ułatwia zrozumienie i utrzymanie kodu.

```python
class ZajebistaKlasa:
    """
    Klasa reprezentująca zajebistą funkcjonalność.

    Ta klasa wykonuje niesamowite czary-mary i zapewnia niezrównaną rozrywkę.

    :param param1: Opisuje parametr pierwszy.
    :param param2: Opisuje parametr drugi.

    .. note::
        Ta klasa wymaga zainstalowanego pakietu `magia` w wersji 2.0 lub wyższej.

    """

    def __init__(self, param1, param2):
        """
        Inicjalizuje instancję klasy ZajebistaKlasa.

        :param param1: Opisuje parametr pierwszy.
        :param param2: Opisuje parametr drugi.
        """

        self.param1 = param1
        self.param2 = param2

    def wykonaj_zajebista_funkcja(self, argument):
        """
        Wykonuje zajebistą funkcję.

        Ta funkcja przyjmuje jeden argument i wykonuje nad nim
        niesamowitą operację.

        :param argument: Opisuje argument funkcji.
        :return: Wynik niesamowitej operacji.
        :raises ValueError: Jeśli argument ma wartość ujemną.

        Przykłady użycia:
            >>> obj = ZajebistaKlasa(42, "Lorem ipsum")
            >>> obj.wykonaj_zajebista_funkcja(10)
            420
            >>> obj.wykonaj_zajebista_funkcja(-5)
            Traceback (most recent call last):
                ...
            ValueError: Argument musi być nieujemny.

        """

        if argument < 0:
            raise ValueError("Argument musi być nieujemny.")

        # Niesamowita operacja
        result = self.param1 * argument

        return result

    @staticmethod
    def metoda_statyczna():
        """
        Wykonuje metodę statyczną.

        Ta metoda jest statyczna i nie wymaga instancji klasy.
        Wykonuje niesamowite czary-mary.

        """

        # Niesamowite czary-mary
        print("Jestem niesamowitą metodą statyczną!")



```

Przykłąd chatGPT:

```python

from datetime import datetime
from time import perf_counter_ns, sleep
from dataclasses import dataclass


@dataclass(init=True)
class Timer:
    """
    Timer is a context manager that measures the execution time of a code block.
    It captures the start time, end time, and duration of the code block.

    Usage:
    ------
    with Timer() as timer:
        # Code block to measure execution time

    Attributes:
    -----------
    start_date (datetime): Start date and time of the code block execution.
    end_date (datetime): End date and time of the code block execution.
    start_time_ns (int): Start time in nanoseconds.
    end_time_ns (int): End time in nanoseconds.

    Methods:
    --------
    __post_init__(): Initializes the Timer instance with the start date and time.
    __enter__(): Enters the context and returns the Timer instance.
    __exit__(exc_type, exc_val, exc_tb): Exits the context and displays the execution time.
    current_datetime(date: datetime) -> str: Formats a datetime object as a string.
    calculate_duration() -> tuple[int]: Calculates the duration of the code block in hours, minutes, seconds,
                                        milliseconds, microseconds, and nanoseconds.
    calculate_duration_alt() -> tuple[float]: Calculates the duration of the code block in hours, minutes, and seconds
                                              using an alternative method.
    display_time(): Displays the start date, end date, and duration of the code block execution.

    """

    start_date: datetime = None
    end_date: datetime = None
    start_time_ns: int = None
    end_time_ns: int = None

    def __post_init__(self):
        self.start_date = datetime.now()
        self.start_time_ns = perf_counter_ns()

    def __enter__(self) -> 'Timer':
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        try:
            self.end_date = datetime.now()
            self.end_time_ns = perf_counter_ns()
            self.display_time()
        except Exception as e:
            print(f'An error occurred: {e}')

    def current_datetime(self, date: datetime) -> str:
        """
        Formats a datetime object as a string in the format 'YYYY-MM-DD HH:MM:SS'.

        Args:
        -----
        date (datetime): The datetime object to format.

        Returns:
        --------
        str: The formatted string representing the datetime.

        """
        return f'{date.year}-{date.month:02d}-{date.day:02d} {date.hour:02d}:{date.minute:02d}:{date.second:02d}'

    def calculate_duration(self) -> tuple[int]:
        """
        Calculates the duration of the code block in hours, minutes, seconds, milliseconds,
        microseconds, and nanoseconds.

        Returns:
        --------
        tuple[int]: The duration of the code block in hours, minutes, seconds, milliseconds,
                    microseconds, and nanoseconds.

        """
        duration_ns = self.end_time_ns - self.start_time_ns
        duration_s, duration_ns = divmod(duration_ns, 1_000_000_000)
        duration_ms, duration_ns = divmod(duration_ns, 1_000_000)
        duration_us, duration_ns = divmod(duration_ns, 1_000)

        hours, remainder = divmod(duration_s, 3600)
        minutes, seconds = divmod(remainder, 60)

        return hours, minutes, seconds, duration_ms, duration_us, duration_ns

    def calculate_duration_alt(self) -> tuple[float, float, float]:
        """
        Calculates the duration of the code block in hours, minutes, and seconds
        using an alternative method.

        Returns:
        --------
        tuple[float]: The duration of the code block in hours, minutes, and seconds.

        """
        duration_ns = self.end_time_ns - self.start_time_ns
        hours_alt = duration_ns / 1_000_000_000 / 3600
        minutes_alt = duration_ns / 1_000_000_000 / 60
        seconds_alt = duration_ns / 1_000_000_000

        return hours_alt, minutes_alt, seconds_alt

    def display_time(self):
        """
        Displays the start date, end date, and duration of the code block execution.

        """
        start_date_str = self.current_datetime(self.start_date)
        end_date_str = self.current_datetime(self.end_date)
        hours, minutes, seconds, duration_ms, duration_us, duration_ns = self.calculate_duration()
        hours_alt, minutes_alt, seconds_alt = self.calculate_duration_alt()

        print('        YYYY-MM-DD HH:MM:SS:ms :µs :ns')
        print(f'[START] {start_date_str}')
        print(f'[END]   {end_date_str}')
        print(
            f'[TIME]  YYYY-MM-DD {hours:02d}:{minutes:02d}:{seconds:02d}:{duration_ms:03d}:{duration_us:03d}:{duration_ns:03d}')
        print()

        print(f'[TIME]  {hours_alt:.10f} hours')
        print(f'[TIME]  {minutes_alt:.10f} minutes')
        print(f'[TIME]  {seconds_alt} seconds')


def calculate_sum(n: int) -> int:
    """
        Calculates the sum of integers from 1 to n.
        Args:
        -----
        n (int): The upper limit of the range.

        Returns:
        --------
        int: The sum of integers from 1 to n.

    """
    sum_result = 0
    for i in range(1, n + 1):
        sum_result += i
        sleep(.5)  # Simulating a time-consuming operation
    return sum_result


def main():
    """
    Main function to execute the code block with the Timer context manager.
    """
    sum_result = calculate_sum(1)
    print(f'Sum of 1..1000 = {sum_result}')


with Timer():
    main()

print(Timer.__doc__)

```

# File I/O

```python
# Otwieranie pliku do odczytu
with open('nazwa_pliku.txt', 'r') as file:
    data = file.read()  # Odczytanie danych z pliku
    print(data)

# Otwieranie pliku do zapisu
with open('nazwa_pliku.txt', 'w') as file:
    file.write('Hello, world!')  # Zapisanie danych do pliku

# Otwieranie pliku do dopisywania
with open('nazwa_pliku.txt', 'a') as file:
    file.write('Dodatkowe dane')  # Dopisanie danych na końcu pliku

# Otwieranie pliku w trybie binarnym do odczytu
with open('nazwa_pliku.txt', 'rb') as file:
    binary_data = file.read()  # Odczytanie danych binarnych

# Ustawienie pozycji wskaźnika i odczytanie danych od określonego miejsca
with open('nazwa_pliku.txt', 'r') as file:
    file.seek(5)  # Ustawienie pozycji wskaźnika na 5 bajcie
    data = file.read()  # Odczytanie danych od pozycji 5 do końca pliku
    print(data)

# Pobranie aktualnej pozycji wskaźnika
with open('nazwa_pliku.txt', 'r') as file:
    position = file.tell()  # Pobranie aktualnej pozycji wskaźnika
    print(position)

# Skrócenie pliku do określonej długości
with open('nazwa_pliku.txt', 'r+') as file:
    file.seek(10)  # Ustawienie pozycji wskaźnika
    file.truncate()  # Skrócenie pliku od pozycji 10 do końca

```

# GLOB

Moduł "import glob" w Pythonie umożliwia przeszukiwanie plików i katalogów z wykorzystaniem wzorców. Oto kilka przykładów użycia modułu "glob" wraz z komentarzami:

```python
import os
import glob

# ? zastępuje każdy jeden znak
print(glob.glob('?ndex.py'))

# * zastępuje dowolną ilość znaków
print(glob.glob('*.py'))

# [] zastępuje jeden znak z podanego zakresu
print(glob.glob('[a-c]ndex.py'))
print(glob.glob('[a-c]*.py'))

# [!] zastępuje jeden znak spoza podanego zakresu
print(glob.glob('[!a-c]*.py'))

# ** zastępuje dowolną ilość folderów
globs = glob.glob('**/*.py',
                  root_dir=os.getcwd(),
                  recursive=True,
                  include_hidden=True)  # Python 3.11

# generator oszczędza pamięć
globs = glob.iglob('**/*.py',
                   root_dir=os.getcwd(),
                   recursive=True,
                   include_hidden=True)  # Python 3.11

for i, file in enumerate(globs):
    print(i, file, sep=': ')


import glob

# Przykład 1: Wyszukiwanie plików rozpoczynających się od cyfry
result1 = glob.glob('./[0-9].*')
# Zwraca listę plików, które rozpoczynają się od cyfry w bieżącym katalogu
# Output: ['./1.gif', './2.txt']

# Przykład 2: Wyszukiwanie plików z rozszerzeniem .gif
result2 = glob.glob('*.gif')
# Zwraca listę plików z rozszerzeniem .gif w bieżącym katalogu
# Output: ['1.gif', 'card.gif']

# Przykład 3: Wyszukiwanie pliku z jednym znakiem przed rozszerzeniem .gif
result3 = glob.glob('?.gif')
# Zwraca plik z jednym znakiem przed rozszerzeniem .gif w bieżącym katalogu
# Output: ['1.gif']

# Przykład 4: Wyszukiwanie plików tekstowych w bieżącym katalogu i podkatalogach
result4 = glob.glob('**/*.txt', recursive=True)
# Zwraca listę plików tekstowych w bieżącym katalogu i wszystkich podkatalogach
# Output: ['2.txt', 'sub/3.txt']

# Przykład 5: Wyszukiwanie katalogów w bieżącym katalogu i podkatalogach
result5 = glob.glob('./**/', recursive=True)
# Zwraca listę katalogów w bieżącym katalogu i wszystkich podkatalogach
# Output: ['./', './sub/']

```

# PICKLE

Biblioteka Pickle w Pythonie służy do serializacji i deserializacji obiektów. Serializacja to proces konwersji obiektu Pythona na strumień bajtów, a deserializacja to proces konwersji strumienia bajtów na obiekt Pythona. W ten sposób możemy zapisać obiekt Pythona do pliku i później go odczytać z tego pliku.

```python
import pickle

# Przykład 1: Serializacja obiektu do pliku
data = {'name': 'John', 'age': 30, 'city': 'New York'}
with open('data.pickle', 'wb') as f:
    pickle.dump(data, f)

# Przykład 2: Deserializacja obiektu z pliku
with open('data.pickle', 'rb') as f:
    loaded_data = pickle.load(f)
print(loaded_data)
# Output: {'name': 'John', 'age': 30, 'city': 'New York'}

# Przykład 3: Serializacja i deserializacja listy obiektów
students = [{'name': 'Alice', 'age': 20}, {
    'name': 'Bob', 'age': 22}, {'name': 'Charlie', 'age': 19}]
# Serializacja do postaci łańcucha bajtowego
serialized_data = pickle.dumps(students)
# Deserializacja z łańcucha bajtowego
deserialized_data = pickle.loads(serialized_data)
print(deserialized_data)
# Output: [{'name': 'Alice', 'age': 20}, {'name': 'Bob', 'age': 22}, {'name': 'Charlie', 'age': 19}]
```

```python
import pickle

class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age

# Tworzenie obiektu klasy Person
person = Person("John", 30)

# Serializacja obiektu do pliku
with open('person.pickle', 'wb') as f:
    pickle.dump(person, f)

# Deserializacja obiektu z pliku
with open('person.pickle', 'rb') as f:
    loaded_person = pickle.load(f)

# Wyświetlanie danych załadowanego obiektu
print(loaded_person.name)
print(loaded_person.age)
```

# ASYNCIO

Biblioteka asyncio w Pythonie służy do programowania asynchronicznego. Programowanie asynchroniczne jest techniką programowania, w której zadania są uruchamiane w tle. Nie czekamy na zakończenie jednego zadania, aby rozpocząć kolejne. W ten sposób możemy osiągnąć równoległość w naszym programie.

```python
import asyncio

async def fetch_data(data: int) -> dict:
    print("Fetching data...")  # Wyświetla informację o pobieraniu danych
    await asyncio.sleep(2)  # Asynchroniczne oczekiwanie przez 2 sekundy
    return {"data": data}  # Zwraca słownik z pobranymi danymi

async def counter():
    for i in range(10):
        await asyncio.sleep(.5)  # Asynchroniczne oczekiwanie przez 0.5 sekundy
        print(i)  # Wyświetla aktualną wartość licznika

async def main():
    task1 = asyncio.create_task(fetch_data(1))  # Tworzy zadanie asynchroniczne fetch_data(1)
    task2 = asyncio.create_task(counter())  # Tworzy zadanie asynchroniczne counter()

    data: dict = await task1  # Oczekuje na zakończenie zadania task1 i pobiera zwrócone dane
    print(data)  # Wyświetla pobrane dane
    await task2  # Oczekuje na zakończenie zadania task2

if __name__ == "__main__":
    asyncio.run(main())  # Uruchamia pętlę asynchroniczną asyncio i wykonuje funkcję main()
```

Dzięki bibliotece asyncio możliwe jest równoległe wykonywanie wielu zadań asynchronicznych, co przyspiesza programy, które wymagają czasochłonnych operacji, takich jak pobieranie danych z sieci, przetwarzanie danych lub oczekiwanie na zdarzenia.

Przykład 2 - Poprawna kolejność wykonywania zadań asynchronicznych

```python
import asyncio


async def fetch_data(data: int) -> dict:
    print("Fetching data...")
    await asyncio.sleep(2)
    return {"data": data}


async def main():
    task = asyncio.create_task(fetch_data(100))
    await asyncio.sleep(.1)
    print('Doing something else...')

    data: dict = await task
    print(data)


if __name__ == "__main__":
    asyncio.run(main())

# Output:
# Fetching data...
# Doing something else...
# {'data': 100}

```

Przykład 3 - cancel() - anulowanie zadania asynchronicznego

```python
import asyncio


async def fetch_data(data: int) -> dict:
    print("Fetching data...")
    await asyncio.sleep(2)
    return {"data": data}


async def main():
    task = asyncio.create_task(fetch_data(100))

    task.cancel()

    try:
        data: dict = await task
        print(data)
    except asyncio.CancelledError:
        print("Task was cancelled!")


if __name__ == "__main__":
    asyncio.run(main())

# Output:
# Task was cancelled!
```

Przykład 4 - .done() - sprawdzenie czy zadanie asynchroniczne zostało zakończone

```python
import asyncio


async def fetch_data(data: int) -> dict:
    print("Fetching data...")
    await asyncio.sleep(10) # Zadanie asynchroniczne trwa 10 sekund
    return {"data": data}


async def main():
    task = asyncio.create_task(fetch_data(100))
    await asyncio.sleep(2) # Oczekiwanie 2 sekundy

    try:
        if task.done():
            data: dict = await task
            print(data)
        else:
            print("No data available!")
    except asyncio.CancelledError:
        print("Task was cancelled!")


if __name__ == "__main__":
    asyncio.run(main())

# Output:
# No data available!
```

Przykład 5 - .wait_for() - oczekiwanie na zakończenie zadania asynchronicznego

```python
import asyncio


async def fetch_data(data: int) -> dict:
    print("Fetching data...")
    await asyncio.sleep(3)
    return {"data": data}


async def main():
    task = asyncio.create_task(fetch_data(100))

    try:
        data: dict = await asyncio.wait_for(task, timeout=2)

        print("Data:", data)
    except asyncio.TimeoutError:
        print("Timeout!")


if __name__ == "__main__":
    asyncio.run(main())

# Output:
# Timeout!
```

Przykład 6 - przerywanie pętli asynchronicznej

```python
import asyncio


async def counter():
    for i in range(10 ** 10):
        print(i)

        # Poczeka 0.01 sekundy co 10_000 iteracji, żeby można było przerwać zadanie, dziwne, ale działa
        if i % 10_000 == 0:
            await asyncio.sleep(0.01)
            await asyncio.sleep(0) # Wymusza przełączenie kontekstu, ale jest szybsze niż await asyncio.sleep(0.01)


async def main():
    task = asyncio.create_task(counter())

    await asyncio.sleep(2)
    task.cancel()
    print("Task cancelled")

    await task

if __name__ == "__main__":
    asyncio.run(main())

# Output:
# 0
# ...
# 20000
# Task cancelled
# Error

# ale przy await asyncio.sleep(0)
# 0
# ...
# 40000 -> 2 razy więcej iteracji lol
# Task cancelled
# Error
```

Przykład 7 - asyncio.gather() - oczekiwanie na zakończenie wielu zadań asynchronicznych

```python
import asyncio


async def fetch_data(data: int) -> dict:
    print("Fetching data...")
    await asyncio.sleep(2)

    if data == 0:
        raise ValueError("Invalid data!")
    return {"data": data}


async def main():
    tasks = asyncio.gather(
        fetch_data(1),
        fetch_data(2),
        fetch_data(3),
        fetch_data(0),
        return_exceptions=True
    )

    results = await tasks
    print(results)

if __name__ == "__main__":
    asyncio.run(main())

# Output:
# Fetching data...
# Fetching data...
# Fetching data...
# Fetching data...

# [{'data': 1}, {'data': 2}, {'data': 3}, ValueError('Invalid data!')]
```

Przykład 8

```python
import asyncio


async def main():
    print('Starting the program.')
    # Dawanie await przed sleep powoduje, że sleep jest wykonywane jako coroutine, co pozwala na wykonywanie innych tasków w tym czasie i stwarza możliwość tworzenia kolejnych tasków, może zwracać result
    result = await asyncio.sleep(1, result={'item': 'value'})
    await asyncio.sleep(0)  # Najlepiej stosować to
    Szybka przerwa hej możesz tu zainicjować kolejne taski
    print(f'Result: {result}')

if __name__ == '__main__':
    asyncio.run(main())

# Output:
# Starting the program.
# Result: {'item': 'value'}
```

# Threading

W Pythonie, moduł threading umożliwia programowanie wielowątkowe, co oznacza, że możemy wykonywać wiele wątków jednocześnie w obrębie jednego programu. Wątki są lekkimi procesami, które wykonują się równolegle, dzieląc zasoby procesora. Możemy tworzyć i kontrolować wątki, a każdy wątek może wykonywać różne zadania niezależnie od innych wątków.

Przykład 1

```python
import threading

def print_numbers():
    for i in range(1, 6):
        print(i)

def print_letters():
      for letter in 'ABCDE':
         print(letter)

# Tworzenie wątków
t1 = threading.Thread(target=print_numbers)
t2 = threading.Thread(target=print_letters)

# Uruchamianie wątków
t1.start()
t2.start()

# Oczekiwanie na zakończenie wątków
t1.join()
t2.join()

print("Zakończono wykonanie programu")
```

Moduł `asyncio` natomiast wprowadza inny model programowania asynchronicznego w Pythonie. Zamiast korzystać z wielu wątków, używa się tzw. korutyn (ang. coroutines) do wykonywania operacji asynchronicznych. Główną koncepcją jest wykorzystanie jednego wątku, który przełącza się między różnymi korutynami w momencie oczekiwania na operacje wejścia/wyjścia.

Przykład 2

```python
import asyncio

async def print_numbers():
    for i in range(1, 6):
        print(i)
        await asyncio.sleep(1)

async def print_letters():
    for letter in 'ABCDE':
        print(letter)
        await asyncio.sleep(0.5)

# Tworzenie zadania asynchronicznego
async def main():
    task1 = asyncio.create_task(print_numbers())
    task2 = asyncio.create_task(print_letters())

    # Oczekiwanie na zakończenie zadań
    await asyncio.gather(task1, task2)

    print("Zakończono wykonanie programu")

# Uruchamianie pętli asyncio
asyncio.run(main())
```

W tym przykładzie definiujemy dwie korutyny: print_numbers(), która drukuje liczby od 1 do 5 z opóźnieniem 1 sekundy, i print_letters(), która drukuje litery od A do E z opóźnieniem 0,5 sekundy. Następnie tworzymy zadania asynchroniczne dla obu korutyn i używamy funkcji asyncio.gather(), aby poczekać na zakończenie obu zadań. Na koniec drukujemy komunikat "Zakończono wykonanie programu".

Podsumowując, threading umożliwia programowanie wielowątkowe, gdzie wiele wątków może być wykonywanych równolegle, podczas gdy asyncio wprowadza model programowania asynchronicznego, w którym jednym wątkiem zarządza się korutynami, które mogą być przełączane asynchronicznie w momencie oczekiwania na operacje wejścia/wyjścia.

Przykład 3

```python
import threading

def print_numbers():
    for i in range(1, 6):
        print(i)

def print_letters():
    for letter in 'ABCDE':
        print(letter)

# Tworzenie wątków
t1 = threading.Thread(target=print_numbers)
t2 = threading.Thread(target=print_letters)

# Uruchamianie wątków
t1.start()
t2.start()

# Oczekiwanie na zakończenie wątków
t1.join()
t2.join()

print("Zakończono wykonanie programu")

# Output:
# Thread 1 is starting
# Thread 1: 1
# Thread 1: 2
# Thread 1: 3
# Thread 2 is starting
# Thread 2: 1
# Thread 1: 4
# Thread 2: 2
# Thread 1: 5
# Thread 2: 3
# Thread 2: 4
# Thread 2: 5
```

# Locks

Wielowątkowość może prowadzić do sytuacji, w których wiele wątków próbuje jednocześnie uzyskać dostęp do wspólnych zasobów, co może prowadzić do nieprzewidywalnych i błędnych wyników. Aby zapobiec takim problemom, można używać blokad (locks). Blokady są mechanizmem synchronizacji, które pozwalają wątkom na kontrolowany dostęp do współdzielonych zasobów.

W Pythonie moduł threading dostarcza klasę Lock, która implementuje blokadę. Blokada działa w taki sposób, że tylko jeden wątek może ją posiadać w danym czasie. Pozostałe wątki, które próbują uzyskać dostęp do blokady, muszą czekać, aż zostanie zwolniona przez aktualnie posiadający ją wątek.

Oto przykład użycia blokady Lock:

```python
import threading

counter = 0
lock = threading.Lock()

def increment():
    global counter
    with lock:
        counter += 1

def worker():
    for _ in range(100000):
        increment()

# Tworzenie wątków
threads = []
for _ in range(10):
    t = threading.Thread(target=worker)
    threads.append(t)

# Uruchamianie wątków
for t in threads:
    t.start()

# Oczekiwanie na zakończenie wątków
for t in threads:
    t.join()

print("Wartość licznika:", counter)
```

W tym przykładzie mamy zmienną counter, którą chcemy zwiększać za pomocą wielu wątków. Aby uniknąć równoczesnego dostępu, używamy blokady Lock. Funkcja increment() jest odpowiedzialna za zwiększanie wartości counter w sekcji chronionej przez blokadę. Każdy wątek wywołuje tę funkcję wielokrotnie w pętli w funkcji worker(). Po zakończeniu działania wątków, drukujemy wartość counter.

Dzięki użyciu blokady Lock, mamy pewność, że tylko jeden wątek na raz może modyfikować zmienną counter, co eliminuje możliwość błędów wynikających z równoczesnego dostępu do zasobu.

Warto zauważyć, że moduł asyncio również udostępnia blokady, które można używać w kontekście programowania asynchronicznego. Blokady Lock w asyncio działają w podobny sposób jak w threading, ale są zoptymalizowane do pracy z korutynami i pętlą asyncio.

<!--
lock.acquire()
lock.release()
lock.locked() -->

# lock.acquire(), lock.release(), lock.locked()

lock.acquire() jest metodą używaną do uzyskania blokady. Jeśli blokada jest dostępna, wątek ją otrzymuje i kontynuuje wykonywanie. Jeśli blokada jest już w posiadaniu innego wątku, to wątek, który wywołuje acquire(), zostaje zablokowany do momentu zwolnienia blokady przez inny wątek. Gdy wątek otrzyma blokadę, wykonuje swoje operacje chronione przez blokadę.

Przykład użycia lock.acquire():

```python
import threading

lock = threading.Lock()

def worker():
    lock.acquire()
    try:
        print("Wątek otrzymał blokadę")
        # Wykonywanie operacji chronionych przez blokadę
    finally:
        lock.release()

# Tworzenie wątku
t = threading.Thread(target=worker)

# Uruchamianie wątku
t.start()

# Oczekiwanie na zakończenie wątku
t.join()
```

W powyższym przykładzie, wątek wywołuje lock.acquire(), aby uzyskać blokadę przed wykonaniem operacji chronionych. Jeśli blokada jest dostępna, wątek ją otrzymuje i wykonuje swoje operacje. Następnie, po zakończeniu działania chronionego kodu, wątek wywołuje lock.release(), aby zwolnić blokadę, umożliwiając innym wątkom jej uzyskanie.

lock.release() jest metodą używaną do zwolnienia blokady, która była posiadana przez wątek. Po wywołaniu tej metody blokada staje się dostępna dla innych wątków, które mogą ją otrzymać i kontynuować swoje operacje chronione przez blokadę.

lock.locked() jest metodą używaną do sprawdzenia, czy blokada jest aktualnie posiadana przez jakiś wątek. Zwraca wartość logiczną True, jeśli blokada jest w posiadaniu jakiegoś wątku, lub False, jeśli blokada jest wolna i dostępna dla innych wątków.

Przykład użycia lock.locked():

```python
import threading

lock = threading.Lock()

# Sprawdzenie czy blokada jest posiadana
if lock.locked():
    print("Blokada jest posiadana przez inny wątek")
else:
    print("Blokada jest dostępna")
```

# Daemon Threads

W Pythonie, wątki mogą być ustawione jako "daemon threads" (wątki demony). Wątki demony są wątkami, które działają w tle i są automatycznie zakończane, gdy wszystkie pozostałe wątki nie-demony zostały zakończone. Nie czekają na zakończenie innych wątków przed zakończeniem działania.

Główną cechą wątków demonów jest to, że nie są one blokujące dla zakończenia programu. Jeśli wszystkie wątki, które są uruchomione, są demonami, to w momencie zakończenia działania głównego wątku (głównego programu), wątki demony są automatycznie zatrzymywane, niezależnie od tego, czy zakończyły swoje działanie czy nie.

Aby utworzyć wątek demona w Pythonie przy użyciu modułu threading, można ustawić atrybut daemon wątku na True przed jego uruchomieniem.

Oto przykład użycia wątku demona:

```python
import threading
import time

def daemon_thread():
    while True:
        print("Wątek demon")
        time.sleep(1)

# Tworzenie wątku demona
daemon_thread = threading.Thread(target=daemon_thread)
daemon_thread.daemon = True

# Uruchamianie wątku demona
daemon_thread.start()

# Główny wątek programu
print("Główny wątek programu")
time.sleep(5)
print("Zakończono działanie głównego wątku")
```

W powyższym przykładzie mamy funkcję daemon_thread(), która jest wykonywana przez wątek demona. Funkcja ta wypisuje wiadomość co sekundę w nieskończonej pętli.

Tworzymy wątek demona i ustawiamy jego atrybut daemon na True. Następnie uruchamiamy wątek demona za pomocą start().

W głównym wątku programu drukujemy wiadomość, czekamy 5 sekund (aby dać wystarczająco dużo czasu na działanie wątku demona), a następnie drukujemy komunikat o zakończeniu głównego wątku.

W przypadku wątków demonów, po zakończeniu głównego wątku programu, wątek demona zostanie automatycznie zatrzymany, nawet jeśli nie zakończył swojego działania.

# Semaphores

W Pythonie, semafory są mechanizmem synchronizacji, które pozwalają na kontrolowanie dostępu do zasobów przez określoną liczbę wątków. Semafory są licznikami, które można inkrementować i dekrementować. Każdy wątek próbujący uzyskać dostęp do semafora dekrementuje jego wartość, a jeśli wartość semafora jest większa od zera, wątek może uzyskać dostęp i kontynuować swoje operacje. Jeśli wartość semafora jest równa zero, to wątek zostaje zablokowany do momentu, gdy inny wątek zwolni semafor przez jego inkrementację.

W Pythonie, moduł threading dostarcza klasę Semaphore, która implementuje semafor.

Oto przykład użycia semafora:

```python
import threading

# Tworzenie semafora z liczbą dostępnych "slotów" równą 2
semaphore = threading.Semaphore(2)

def worker():
    # Próba uzyskania dostępu do semafora
    semaphore.acquire()
    try:
        print("Wątek uzyskał dostęp do semafora")
        # Wykonywanie operacji chronionych przez semafor
    finally:
        # Zwolnienie semafora
        semaphore.release()

# Tworzenie wątków
threads = []
for _ in range(5):
    t = threading.Thread(target=worker)
    threads.append(t)

# Uruchamianie wątków
for t in threads:
    t.start()

# Oczekiwanie na zakończenie wątków
for t in threads:
    t.join()
```

W powyższym przykładzie mamy semafor semaphore z liczbą dostępnych "slotów" równą 2. W funkcji worker(), wątek próbuje uzyskać dostęp do semafora za pomocą semaphore.acquire(). Jeśli semafor ma wartość większą od zera, wątek otrzymuje dostęp i wykonuje swoje operacje chronione przez semafor. Po zakończeniu operacji, wątek zwalnia semafor przez wywołanie semaphore.release().

W przypadku, gdy więcej niż 2 wątki próbują uzyskać dostęp do semafora jednocześnie, tylko 2 z nich otrzymają dostęp, a pozostałe zostaną zablokowane do momentu zwolnienia semafora przez któryś z aktywnych wątków.

Semafor jest szczególnie przydatny w sytuacjach, gdy chcemy ograniczyć dostęp do zasobów o określonym rozmiarze, na przykład dostęp do puli połączeń do bazy danych, zasobów sieciowych lub innych zasobów, które mogą być ograniczone pod względem liczby jednoczesnych dostępów.

# Thread with

W Pythonie można użyć semafora Semaphore wraz z blokiem with, który automatycznie zarządza akwizycją (acquire) i zwalnianiem (release) semafora. Dzięki temu nie musisz ręcznie wywoływać metod acquire() i release().

Oto przykład użycia semafora Semaphore z blokiem with:

```python
import threading

# Tworzenie semafora z liczbą dostępnych "slotów" równą 2
semaphore = threading.Semaphore(2)

def worker():
    with semaphore:
        print("Wątek uzyskał dostęp do semafora")
        # Wykonywanie operacji chronionych przez semafor

# Tworzenie wątków
threads = []
for _ in range(5):
    t = threading.Thread(target=worker)
    threads.append(t)

# Uruchamianie wątków
for t in threads:
    t.start()

# Oczekiwanie na zakończenie wątków
for t in threads:
    t.join()
```

W powyższym przykładzie używamy bloku with semaphore, który automatycznie zarządza akwizycją semafora przy wejściu do bloku i jego zwalnianiem po opuszczeniu bloku. Dzięki temu nie musimy wywoływać metod acquire() i release() bezpośrednio.

Po uruchomieniu programu, dwa wątki będą miały jednoczesny dostęp do sekcji chronionej przez semafor, ponieważ mamy semafor z dwoma dostępnymi "slotami". Pozostałe wątki zostaną zablokowane i czekać będą, aż któryś z aktywnych wątków zwolni semafor.

Używanie bloku with w przypadku semafora jest wygodnym sposobem na automatyczne zarządzanie akwizycją i zwalnianiem semafora, zapewniając tym samym poprawne zarządzanie dostępem do chronionych zasobów.'

# Race Conditions

Wyścig (race condition) to sytuacja, która występuje, gdy dwa lub więcej wątków lub procesów wykonuje operacje na współdzielonych danych i kolejność, w jakiej te operacje są wykonywane, zależy od niewłaściwego synchronizowania wątków lub procesów. Wynikiem wyścigu są nieprzewidywalne i często niepożądane efekty, takie jak niepoprawne wartości danych, błędy lub niestabilne działanie programu.

Wyścigi mogą wystąpić w przypadku, gdy:

Współdzielone dane są modyfikowane równocześnie przez wiele wątków lub procesów.
Istnieje brak synchronizacji lub koordynacji między wątkami lub procesami w celu kontrolowania dostępu do współdzielonych danych.
Nie ma odpowiednich mechanizmów synchronizacji, takich jak blokady, semafory, mutexy itp.
Przykładem wyścigu może być sytuacja, w której dwa wątki równocześnie próbują zaktualizować tę samą zmienną współdzieloną. Jeśli nie ma odpowiedniego mechanizmu synchronizacji, oba wątki mogą odczytać starą wartość zmiennej, zaktualizować ją niezależnie i zapisać swoje wyniki. W rezultacie, jedna zaktualizowana wartość zostanie utracona, co prowadzi do nieprawidłowych danych.

Aby uniknąć wyścigów, konieczne jest odpowiednie synchronizowanie dostępu do współdzielonych danych. W Pythonie można użyć mechanizmów synchronizacji, takich jak blokady (Lock), semafory (Semaphore), warunki (Condition) itp., aby zapewnić poprawną synchronizację wątków i uniknąć wyścigów.

Przykład zastosowania blokady (Lock) w celu uniknięcia wyścigu:

```python
import threading

shared_variable = 0
lock = threading.Lock()

def increment():
    global shared_variable
    with lock:
        shared_variable += 1

# Tworzenie wątków
threads = []
for _ in range(10):
    t = threading.Thread(target=increment)
    threads.append(t)

# Uruchamianie wątków
for t in threads:
    t.start()

# Oczekiwanie na zakończenie wątków
for t in threads:
    t.join()

# Wyświetlanie wyniku
print("Wartość zmiennej współdzielonej:", shared_variable)
```

W tym przykładzie używamy blokady (Lock), aby synchronizować dostęp do zmiennej shared_variable. Każdy wątek przed wykonaniem operacji inkrementacji zmiennych najpierw musi uzyskać blokadę. Dzięki temu tylko jeden wątek na raz ma dostęp do zmiennej i unikamy wyścigu.

# Multiprocessing

Multiprocessing to moduł w Pythonie, który umożliwia wykonywanie równoległego i współbieżnego kodu poprzez uruchamianie procesów, a nie wątków. W przeciwieństwie do modułu threading, który obsługuje wielowątkowość, moduł multiprocessing obsługuje wieloprocesowość.

W wielowątkowości (moduł threading), kilka wątków jest wykonywanych w obrębie jednego procesu, a wątki współdzielą te same zasoby, takie jak pamięć. Wielowątkowość może być przydatna do równoczesnego wykonywania wielu zadań, ale ma pewne ograniczenia, takie jak global interpreter lock (GIL), który może ograniczać równoległe wykonanie kodu.

W wieloprocesowości (moduł multiprocessing), różne procesy są uruchamiane równolegle i posiadają swoje własne przestrzenie adresowe. Procesy nie dzielą tych samych zasobów, co oznacza, że nie występuje problem z GIL-em. Każdy proces ma własną kopię zmiennych, pamięć i innych zasobów, co umożliwia równoległe wykonanie kodu.

Główne różnice między wielowątkowością (threading) a wieloprocesowością (multiprocessing) to:

Pamięć: W wielowątkowości wątki współdzielą tę samą pamięć, podczas gdy w wieloprocesowości każdy proces ma swoją niezależną przestrzeń adresową.

GIL: Wielowątkowość jest ograniczana przez global interpreter lock (GIL), który uniemożliwia równoległe wykonanie kodu Pythona w wielu wątkach. Wieloprocesowość unika tego problemu, ponieważ każdy proces ma własny interpreter Pythona.

Komunikacja między procesami: W wielowątkowości komunikacja między wątkami może być realizowana przez współdzielenie danych w pamięci lub wykorzystanie synchronizacji takiej jak blokady (Lock). W wieloprocesowości komunikacja między procesami wymaga specjalnych mechanizmów, takich jak kolejki (Queue), potoki (Pipe) lub współdzielenie pamięci (shared memory).

Moduł asyncio natomiast jest innym podejściem do asynchronicznego programowania w Pythonie. Zamiast tworzyć wiele wątków lub procesów, asyncio opiera się na asynchroniczności, wykorzystując tzw. "awaitables" (obiekty oczekujące), takie jak korutyny, aby wykonywać operacje asynchronicznie. To umożliwia wykonywanie wielu operacji I/O (wejścia/wyjścia) bez blokowania wątku. asyncio ma swoje własne pętle zdarzeń (event loop), które obsługują asynchroniczne zadania.

Podsumowując, różnica między modułami threading i multiprocessing polega na tym, że threading obsługuje wielowątkowość w obrębie jednego procesu, multiprocessing obsługuje wieloprocesowość przez uruchamianie różnych procesów, a asyncio oferuje asynchroniczne programowanie przy użyciu korutyn i pętli zdarzeń. Każde podejście ma swoje własne zastosowanie i może być używane w zależności od konkretnych wymagań i sytuacji.

Wybór między modułami threading, multiprocessing i asyncio zależy od konkretnych potrzeb i kontekstu aplikacji. Oto kilka wskazówek, które mogą pomóc w podjęciu decyzji:

Wielowątkowość (threading):

Przydatna, gdy chcesz osiągnąć współbieżność w obrębie jednego procesu.
Wykorzystywana do równoczesnego wykonania wielu zadań nieblokujących, takich jak operacje I/O (wejście/wyjście).
Ograniczenia GIL mogą występować, co może wpływać na wydajność w niektórych przypadkach.
Przykłady zastosowań: równoległe pobieranie danych z wielu źródeł, obsługa wielu klientów w serwerze.
Wieloprocesowość (multiprocessing):

Przydatna, gdy chcesz osiągnąć równoległość poprzez uruchamianie różnych procesów.
Każdy proces ma własną przestrzeń adresową, co eliminuje problemy z GIL-em.
Wykorzystywana, gdy chcesz wykorzystać wielordzeniowy procesor do zwiększenia wydajności.
Komunikacja między procesami wymaga specjalnych mechanizmów, takich jak kolejki czy potoki.
Przykłady zastosowań: przetwarzanie danych w obrębie różnych procesów, obliczenia równoległe.
Asynchroniczność (asyncio):

Przydatne, gdy chcesz osiągnąć efektywne operacje I/O i reagowanie na zdarzenia.
Korzysta z asynchronicznych operacji wejścia/wyjścia, takich jak oczekiwanie na dane z sieci.
Wykorzystuje korutyny i pętlę zdarzeń do zarządzania asynchronicznymi zadaniami.
Przykłady zastosowań: serwery sieciowe, aplikacje obsługujące wiele klientów, programy komunikujące się z usługami sieciowymi.
Pamiętaj, że wybór odpowiedniego modułu zależy od charakterystyki problemu, wymagań dotyczących wydajności, rodzaju operacji (blokujące vs nieblokujące) i innych czynników specyficznych dla danej aplikacji. W niektórych przypadkach można również łączyć różne podejścia, np. używać asyncio do zarządzania asynchronicznymi operacjami I/O i korzystać z threading lub multiprocessing do przetwarzania równoległego w obrębie tych operacji.
